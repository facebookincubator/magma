#!/usr/bin/env python3
from graphql import GraphQLSchema

from .utils_codegen import CodeChunk
from .query_parser import ParsedQuery, ParsedField, ParsedObject, ParsedEnum, \
    ParsedOperation, ParsedVariableDefinition


class DataclassesRenderer:

    def __init__(self, schema: GraphQLSchema):
        self.schema = schema

    def render(self, parsed_query: ParsedQuery):
        # We sort fragment nodes to be first and operations to be last because
        # of dependecies
        buffer = CodeChunk()
        buffer.write("#!/usr/bin/env python3")
        buffer.write("# @" + "generated AUTOGENERATED file. Do not Change!")
        buffer.write("")
        buffer.write("from dataclasses import dataclass, field")
        buffer.write("from datetime import datetime")
        buffer.write("from enum import Enum")
        buffer.write("from functools import partial")
        buffer.write("from typing import Any, Callable, List, Mapping, Optional")
        buffer.write("")
        buffer.write("from dataclasses_json import dataclass_json")
        buffer.write("from marshmallow import fields as marshmallow_fields")
        buffer.write("")
        buffer.write("from .datetime_utils import fromisoformat")
        buffer.write("")

        self.__render_datetime_field(buffer)

        # Enums
        if parsed_query.enums:
            buffer.write('')
            self.__render_enum_field(buffer)
            for enum in parsed_query.enums:
                buffer.write('')
                self.__render_enum(buffer, enum)

        sorted_objects = sorted(parsed_query.objects, key=lambda obj: 1 if
            isinstance(obj, ParsedOperation) else 0)
        for obj in sorted_objects:
            buffer.write('')
            if isinstance(obj, ParsedObject):
                self.__render_object(parsed_query, buffer, obj)
            elif isinstance(obj, ParsedOperation):
                self.__render_operation(parsed_query, buffer, obj)

        return str(buffer)

    @staticmethod
    def __render_enum_field(buffer: CodeChunk):
        with buffer.write_block('def enum_field(enum_type):'):
            with buffer.write_block('def encode_enum(value):'):
                buffer.write('return value.value')
            buffer.write('')
            with buffer.write_block('def decode_enum(t, value):'):
                buffer.write('return t(value)')

            buffer.write('')
            buffer.write("return field(")
            buffer.write("    metadata={")
            buffer.write('        "dataclasses_json": {')
            buffer.write('            "encoder": encode_enum,')
            buffer.write('            "decoder": partial(decode_enum, enum_type),')
            buffer.write("        }")
            buffer.write("    }")
            buffer.write(")")
            buffer.write('')

    @staticmethod
    def __render_datetime_field(buffer: CodeChunk):
        buffer.write('')
        buffer.write("DATETIME_FIELD = field(")
        buffer.write("    metadata={")
        buffer.write('        "dataclasses_json": {')
        buffer.write('            "encoder": datetime.isoformat,')
        buffer.write('            "decoder": fromisoformat,')
        buffer.write('            "mm_field": marshmallow_fields.DateTime'
         + '(format="iso"),')
        buffer.write("        }")
        buffer.write("    }")
        buffer.write(")")
        buffer.write('')

    def __render_object(
            self, parsed_query: ParsedQuery, buffer: CodeChunk, obj: ParsedObject):
        class_parents = '' if not obj.parents else f'({", ".join(obj.parents)})'

        buffer.write('@dataclass_json')
        buffer.write('@dataclass')
        with buffer.write_block(f'class {obj.name}{class_parents}:'):
            # render child objects
            for child_object in obj.children:
                self.__render_object(parsed_query, buffer, child_object)

            # render fields
            sorted_fields = sorted(obj.fields, key=lambda f: 1 if f.nullable else 0)
            for field in sorted_fields:
                self.__render_field(parsed_query, buffer, field)

            # pass if not children or fields
            if not (obj.children or obj.fields):
                buffer.write('pass')

        buffer.write('')

    def __render_operation(
            self,
            parsed_query: ParsedQuery,
            buffer: CodeChunk,
            parsed_op: ParsedOperation):
        buffer.write('@dataclass_json')
        buffer.write('@dataclass')
        with buffer.write_block(f'class {parsed_op.name}:'):
            buffer.write('__QUERY__ = """')
            buffer.write(parsed_query.query)
            buffer.write('"""')
            buffer.write('')

            # Render children
            for child_object in parsed_op.children:
                self.__render_object(parsed_query, buffer, child_object)

            # operation fields
            buffer.write(f'data: Optional[{parsed_op.name}Data] = None')
            buffer.write('errors: Any = None')
            buffer.write('')

            # Execution functions
            if parsed_op.variables:
                vars_args = ', ' + ', '.join([self.__render_variable_definition(var)
                    for var in parsed_op.variables])
                variables_dict = '{' + ', '.join(f'"{var.name}": {var.name}'
                    for var in parsed_op.variables) + '}'
            else:
                vars_args = ''
                variables_dict = 'None'

            buffer.write('@classmethod')
            buffer.write('# fmt: off')
            with buffer.write_block(f'def execute(cls, client{vars_args}):'):
                buffer.write('# fmt: off')
                buffer.write(f'variables = {variables_dict}')
                buffer.write('response_text = client.call(cls.__QUERY__, '
                    'variables=variables)')
                buffer.write('return cls.from_json(response_text).data')

            buffer.write('')

    @staticmethod
    def __render_variable_definition(var: ParsedVariableDefinition):
        var_type = var.type

        if var_type == 'DateTime':
            var_type = 'datetime'
        elif var_type == 'Cursor':
            var_type = 'str'

        if var.is_list:
            return f'{var.name}: List[{var_type}] = []'

        if not var.nullable:
            return f'{var.name}: {var_type}'

        return f'{var.name}: Optional[{var_type}] = {var.default_value or "None"}'

    @staticmethod
    def __render_field(
            parsed_query: ParsedQuery, buffer: CodeChunk, field: ParsedField):
        enum_names = [e.name for e in parsed_query.enums]
        is_enum = field.type in enum_names
        suffix = ''
        field_type = field.type

        if is_enum:
            suffix = f' = enum_field({field.type})'

        if field.type == 'DateTime':
            suffix = ' = DATETIME_FIELD'
            field_type = 'datetime'

        if field.nullable:
            suffix = f' = {field.default_value}'
            buffer.write(f'{field.name}: Optional[{field_type}]{suffix}')
        else:
            buffer.write(f'{field.name}: {field_type}{suffix}')

    @staticmethod
    def __render_enum(buffer: CodeChunk, enum: ParsedEnum):
        with buffer.write_block(f'class {enum.name}(Enum):'):
            for value_name, value in enum.values.items():
                if isinstance(value, str):
                    value = f'"{value}"'

                buffer.write(f'{value_name} = {value}')

        buffer.write('')
