{{ define "pagination" }}
{{ template "header" $ }}

import (
    "github.com/facebookincubator/symphony/pkg/graphql/relay"
)

// ErrInvalidPagination error is returned when paginating with invalid parameters.
var ErrInvalidPagination = errors.New("ent: invalid pagination parameters")

{{ range $node := $.Nodes -}}
{{ $edge := print $node.Name "Edge" -}}
// {{ $edge }} is the edge representation of {{ $node.Name }}.
type {{ $edge }} struct {
    Node *{{ $node.Name }} `json:"node"`
    Cursor *relay.Cursor   `json:"cursor"`
}

{{ $conn := print $node.Name "Connection" -}}
// {{ $conn }} is the connection containing edges to {{ $node.Name }}.
type {{ $conn }} struct {
    Edges []*{{ $edge }}     `json:"edges"`
    PageInfo *relay.PageInfo `json:"pageInfo"`
}

func new{{ $conn }}() *{{ $conn }} {
    return &{{ $conn }}{
        Edges: []*{{ $edge }}{},
        PageInfo: &relay.PageInfo{},
    }
}

{{ $query := print $node.Name "Query" -}}
{{ $receiver := $node.Receiver -}}
{{ $pkg := $node.Package -}}
// Paginate executes the query and returns a relay based cursor connection to {{ $node.Name }}.
func ({{ $receiver }} *{{ $query }}) Paginate(ctx context.Context, after *relay.Cursor, first *int, before *relay.Cursor, last *int) (*{{ $conn }}, error) {
    if first != nil && last != nil {
        return nil, ErrInvalidPagination
    }
    if first != nil {
        if *first == 0 {
            return new{{ $conn }}(), nil
        } else if *first < 0 {
            return nil, ErrInvalidPagination
        }
    }
    if last != nil {
        if *last == 0 {
            return new{{ $conn }}(), nil
        } else if *last < 0 {
            return nil, ErrInvalidPagination
        }
    }

    if after != nil {
        {{ $receiver }} = {{ $receiver }}.Where({{ $pkg }}.IDGT(after.ID))
    }
    if before != nil {
        {{ $receiver }} = {{ $receiver }}.Where({{ $pkg }}.IDLT(before.ID))
    }
    if first != nil {
        {{ $receiver }} = {{ $receiver }}.Order(Asc({{ $pkg }}.FieldID)).Limit(*first + 1)
    }
    if last != nil {
        {{ $receiver }} = {{ $receiver }}.Order(Desc({{ $pkg }}.FieldID)).Limit(*last + 1)
    }

    nodes, err := {{ $receiver }}.All(ctx)
    if err != nil || len(nodes) == 0 {
        return new{{ $conn }}(), err
    }
    if last != nil {
        for left, right := 0, len(nodes)-1; left < right; left, right = left+1, right-1 {
            nodes[left], nodes[right] = nodes[right], nodes[left]
        }
    }

    info := &relay.PageInfo{}
    if first != nil && len(nodes) > *first {
        info.HasNextPage = true
        nodes = nodes[:len(nodes)-1]
    } else if last != nil && len(nodes) > *last {
        info.HasPreviousPage = true
        nodes = nodes[1:]
    }
    edges := make([]*{{ $edge }}, len(nodes))
    for i, node := range nodes {
        edges[i] = &{{ $edge }}{
            Node: node,
            Cursor: &relay.Cursor{
                ID: node.ID,
            },
        }
    }
    info.StartCursor = edges[0].Cursor
    info.EndCursor = edges[len(edges)-1].Cursor

    return &{{ $conn }}{
        Edges: edges,
        PageInfo: info,
    }, nil
}

{{ end }}
{{ end }}
