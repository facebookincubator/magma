<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - /home/vagrant/build/c/oai/tasks/s1ap/r15/OCTET_STRING.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">home/vagrant/build/c/oai/tasks/s1ap/r15</a> - OCTET_STRING.c<span style="font-size: 80%;"> (source / <a href="OCTET_STRING.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">173</td>
            <td class="headerCovTableEntry">1070</td>
            <td class="headerCovTableEntryLo">16.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2021-02-17 15:02:47</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">19.4 %</td>
          </tr>
          <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*-</a>
<span class="lineNum">       2 </span>            :  * Copyright (c) 2003-2017 Lev Walkin &lt;vlm@lionet.info&gt;.
<span class="lineNum">       3 </span>            :  * All rights reserved.
<span class="lineNum">       4 </span>            :  * Redistribution and modifications are permitted subject to BSD license.
<span class="lineNum">       5 </span>            :  */
<span class="lineNum">       6 </span>            : #include &lt;asn_internal.h&gt;
<span class="lineNum">       7 </span>            : #include &lt;OCTET_STRING.h&gt;
<span class="lineNum">       8 </span>            : #include &lt;BIT_STRING.h&gt;   /* for .bits_unused member */
<span class="lineNum">       9 </span>            : #include &lt;errno.h&gt;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : /*
<span class="lineNum">      12 </span>            :  * OCTET STRING basic type description.
<span class="lineNum">      13 </span>            :  */
<span class="lineNum">      14 </span>            : static const ber_tlv_tag_t asn_DEF_OCTET_STRING_tags[] = {
<span class="lineNum">      15 </span>            :         (ASN_TAG_CLASS_UNIVERSAL | (4 &lt;&lt; 2))
<span class="lineNum">      16 </span>            : };
<span class="lineNum">      17 </span>            : asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs = {
<span class="lineNum">      18 </span>            :         sizeof(OCTET_STRING_t),
<span class="lineNum">      19 </span>            :         offsetof(OCTET_STRING_t, _asn_ctx),
<span class="lineNum">      20 </span>            :         ASN_OSUBV_STR
<span class="lineNum">      21 </span>            : };
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : asn_TYPE_operation_t asn_OP_OCTET_STRING = {
<span class="lineNum">      24 </span>            :         OCTET_STRING_free,
<span class="lineNum">      25 </span>            :         OCTET_STRING_print,     /* OCTET STRING generally means a non-ascii sequence */
<span class="lineNum">      26 </span>            :         OCTET_STRING_compare,
<span class="lineNum">      27 </span>            :         OCTET_STRING_decode_ber,
<span class="lineNum">      28 </span>            :         OCTET_STRING_encode_der,
<span class="lineNum">      29 </span>            :         OCTET_STRING_decode_xer_hex,
<span class="lineNum">      30 </span>            :         OCTET_STRING_encode_xer,
<span class="lineNum">      31 </span>            : #ifdef  ASN_DISABLE_OER_SUPPORT
<span class="lineNum">      32 </span>            :         0,
<span class="lineNum">      33 </span>            :         0,
<span class="lineNum">      34 </span>            : #else
<span class="lineNum">      35 </span>            :         OCTET_STRING_decode_oer,
<span class="lineNum">      36 </span>            :         OCTET_STRING_encode_oer,
<span class="lineNum">      37 </span>            : #endif  /* ASN_DISABLE_OER_SUPPORT */
<span class="lineNum">      38 </span>            : #ifdef  ASN_DISABLE_PER_SUPPORT
<span class="lineNum">      39 </span>            :         0,
<span class="lineNum">      40 </span>            :         0,
<span class="lineNum">      41 </span>            :         0,
<span class="lineNum">      42 </span>            :         0,
<span class="lineNum">      43 </span>            : #else
<span class="lineNum">      44 </span>            :         OCTET_STRING_decode_uper,       /* Unaligned PER decoder */
<span class="lineNum">      45 </span>            :         OCTET_STRING_encode_uper,       /* Unaligned PER encoder */
<span class="lineNum">      46 </span>            :         OCTET_STRING_decode_aper,       /* Aligned PER decoder */
<span class="lineNum">      47 </span>            :         OCTET_STRING_encode_aper,       /* Aligned PER encoder */
<span class="lineNum">      48 </span>            : #endif  /* ASN_DISABLE_PER_SUPPORT */
<span class="lineNum">      49 </span>            :         OCTET_STRING_random_fill,
<span class="lineNum">      50 </span>            :         0       /* Use generic outmost tag fetcher */
<span class="lineNum">      51 </span>            : };
<span class="lineNum">      52 </span>            : asn_TYPE_descriptor_t asn_DEF_OCTET_STRING = {
<span class="lineNum">      53 </span>            :         &quot;OCTET STRING&quot;,               /* Canonical name */
<span class="lineNum">      54 </span>            :         &quot;OCTET_STRING&quot;,               /* XML tag name */
<span class="lineNum">      55 </span>            :         &amp;asn_OP_OCTET_STRING,
<span class="lineNum">      56 </span>            :         asn_DEF_OCTET_STRING_tags,
<span class="lineNum">      57 </span>            :         sizeof(asn_DEF_OCTET_STRING_tags)
<span class="lineNum">      58 </span>            :           / sizeof(asn_DEF_OCTET_STRING_tags[0]),
<span class="lineNum">      59 </span>            :         asn_DEF_OCTET_STRING_tags,      /* Same as above */
<span class="lineNum">      60 </span>            :         sizeof(asn_DEF_OCTET_STRING_tags)
<span class="lineNum">      61 </span>            :           / sizeof(asn_DEF_OCTET_STRING_tags[0]),
<span class="lineNum">      62 </span>            :         { 0, 0, asn_generic_no_constraint },
<span class="lineNum">      63 </span>            :         0, 0,   /* No members */
<span class="lineNum">      64 </span>            :         &amp;asn_SPC_OCTET_STRING_specs
<span class="lineNum">      65 </span>            : };
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : #undef  _CH_PHASE
<span class="lineNum">      68 </span>            : #undef  NEXT_PHASE
<span class="lineNum">      69 </span>            : #undef  PREV_PHASE
<span class="lineNum">      70 </span>            : #define _CH_PHASE(ctx, inc) do {                                        \
<span class="lineNum">      71 </span>            :                 if(ctx-&gt;phase == 0)                                  \
<span class="lineNum">      72 </span>            :                         ctx-&gt;context = 0;                            \
<span class="lineNum">      73 </span>            :                 ctx-&gt;phase += inc;                                   \
<span class="lineNum">      74 </span>            :         } while(0)
<span class="lineNum">      75 </span>            : #define NEXT_PHASE(ctx) _CH_PHASE(ctx, +1)
<span class="lineNum">      76 </span>            : #define PREV_PHASE(ctx) _CH_PHASE(ctx, -1)
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : #undef  ADVANCE
<span class="lineNum">      79 </span>            : #define ADVANCE(num_bytes)      do {                                    \
<span class="lineNum">      80 </span>            :                 size_t num = (num_bytes);                               \
<span class="lineNum">      81 </span>            :                 buf_ptr = ((const char *)buf_ptr) + num;                \
<span class="lineNum">      82 </span>            :                 size -= num;                                            \
<span class="lineNum">      83 </span>            :                 consumed_myself += num;                                 \
<span class="lineNum">      84 </span>            :         } while(0)
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            : #undef  RETURN
<span class="lineNum">      87 </span>            : #define RETURN(_code)   do {                                            \
<span class="lineNum">      88 </span>            :                 asn_dec_rval_t tmprval;                                 \
<span class="lineNum">      89 </span>            :                 tmprval.code = _code;                                   \
<span class="lineNum">      90 </span>            :                 tmprval.consumed = consumed_myself;                     \
<span class="lineNum">      91 </span>            :                 return tmprval;                                         \
<span class="lineNum">      92 </span>            :         } while(0)
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            : #undef  APPEND
<span class="lineNum">      95 </span>            : #define APPEND(bufptr, bufsize) do {                                    \
<span class="lineNum">      96 </span>            :                 size_t _bs = (bufsize);         /* Append size */       \
<span class="lineNum">      97 </span>            :                 size_t _ns = ctx-&gt;context;   /* Allocated now */     \
<span class="lineNum">      98 </span>            :                 size_t _es = st-&gt;size + _bs; /* Expected size */     \
<span class="lineNum">      99 </span>            :                 /* int is really a typeof(st-&gt;size): */                      \
<span class="lineNum">     100 </span>            :                 if((int)_es &lt; 0) RETURN(RC_FAIL);                    \
<span class="lineNum">     101 </span>            :                 if(_ns &lt;= _es) {                                     \
<span class="lineNum">     102 </span>            :                         void *ptr;                                      \
<span class="lineNum">     103 </span>            :                         /* Be nice and round to the memory allocator */ \
<span class="lineNum">     104 </span>            :                         do { _ns = _ns ? _ns &lt;&lt; 1 : 16; }         \
<span class="lineNum">     105 </span>            :                             while(_ns &lt;= _es);                               \
<span class="lineNum">     106 </span>            :                         /* int is really a typeof(st-&gt;size): */              \
<span class="lineNum">     107 </span>            :                         if((int)_ns &lt; 0) RETURN(RC_FAIL);            \
<span class="lineNum">     108 </span>            :                         ptr = REALLOC(st-&gt;buf, _ns);                 \
<span class="lineNum">     109 </span>            :                         if(ptr) {                                       \
<span class="lineNum">     110 </span>            :                                 st-&gt;buf = (uint8_t *)ptr;            \
<span class="lineNum">     111 </span>            :                                 ctx-&gt;context = _ns;                  \
<span class="lineNum">     112 </span>            :                         } else {                                        \
<span class="lineNum">     113 </span>            :                                 RETURN(RC_FAIL);                        \
<span class="lineNum">     114 </span>            :                         }                                               \
<span class="lineNum">     115 </span>            :                         ASN_DEBUG(&quot;Reallocating into %ld&quot;, (long)_ns);        \
<span class="lineNum">     116 </span>            :                 }                                                       \
<span class="lineNum">     117 </span>            :                 memcpy(st-&gt;buf + st-&gt;size, bufptr, _bs);          \
<span class="lineNum">     118 </span>            :                 /* Convenient nul-termination */                        \
<span class="lineNum">     119 </span>            :                 st-&gt;buf[_es] = '\0';                                 \
<span class="lineNum">     120 </span>            :                 st-&gt;size = _es;                                              \
<span class="lineNum">     121 </span>            :         } while(0)
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /*
<span class="lineNum">     124 </span>            :  * The main reason why ASN.1 is still alive is that too much time and effort
<span class="lineNum">     125 </span>            :  * is necessary for learning it more or less adequately, thus creating a gut
<span class="lineNum">     126 </span>            :  * necessity to demonstrate that aquired skill everywhere afterwards.
<span class="lineNum">     127 </span>            :  * No, I am not going to explain what the following stuff is.
<span class="lineNum">     128 </span>            :  */
<span class="lineNum">     129 </span>            : struct _stack_el {
<span class="lineNum">     130 </span>            :     ber_tlv_len_t left;     /* What's left to read (or -1) */
<span class="lineNum">     131 </span>            :     ber_tlv_len_t got;      /* What was actually processed */
<span class="lineNum">     132 </span>            :     unsigned cont_level;    /* Depth of subcontainment */
<span class="lineNum">     133 </span>            :     int want_nulls;         /* Want null &quot;end of content&quot; octets? */
<span class="lineNum">     134 </span>            :     int bits_chopped;       /* Flag in BIT STRING mode */
<span class="lineNum">     135 </span>            :     ber_tlv_tag_t tag;      /* For debugging purposes */
<span class="lineNum">     136 </span>            :     struct _stack_el *prev;
<span class="lineNum">     137 </span>            :     struct _stack_el *next;
<span class="lineNum">     138 </span>            : };
<span class="lineNum">     139 </span>            : struct _stack {
<span class="lineNum">     140 </span>            :         struct _stack_el *tail;
<span class="lineNum">     141 </span>            :         struct _stack_el *cur_ptr;
<span class="lineNum">     142 </span>            : };
<a name="143"><span class="lineNum">     143 </span>            : </a>
<span class="lineNum">     144 </span>            : static struct _stack_el *
<span class="lineNum">     145 </span><span class="lineNoCov">          0 : OS__add_stack_el(struct _stack *st) {</span>
<span class="lineNum">     146 </span>            :         struct _stack_el *nel;
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :         /*
<span class="lineNum">     149 </span>            :          * Reuse the old stack frame or allocate a new one.
<span class="lineNum">     150 </span>            :          */
<span class="lineNum">     151 </span><span class="lineNoCov">          0 :         if(st-&gt;cur_ptr &amp;&amp; st-&gt;cur_ptr-&gt;next) {</span>
<span class="lineNum">     152 </span><span class="lineNoCov">          0 :                 nel = st-&gt;cur_ptr-&gt;next;</span>
<span class="lineNum">     153 </span><span class="lineNoCov">          0 :                 nel-&gt;bits_chopped = 0;</span>
<span class="lineNum">     154 </span><span class="lineNoCov">          0 :                 nel-&gt;got = 0;</span>
<span class="lineNum">     155 </span>            :                 /* Retain the nel-&gt;cont_level, it's correct. */
<span class="lineNum">     156 </span>            :         } else {
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :                 nel = (struct _stack_el *)CALLOC(1, sizeof(struct _stack_el));</span>
<span class="lineNum">     158 </span><span class="lineNoCov">          0 :                 if(nel == NULL)</span>
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :                         return NULL;</span>
<span class="lineNum">     160 </span>            :         
<span class="lineNum">     161 </span><span class="lineNoCov">          0 :                 if(st-&gt;tail) {</span>
<span class="lineNum">     162 </span>            :                         /* Increase a subcontainment depth */
<span class="lineNum">     163 </span><span class="lineNoCov">          0 :                         nel-&gt;cont_level = st-&gt;tail-&gt;cont_level + 1;</span>
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :                         st-&gt;tail-&gt;next = nel;</span>
<span class="lineNum">     165 </span>            :                 }
<span class="lineNum">     166 </span><span class="lineNoCov">          0 :                 nel-&gt;prev = st-&gt;tail;</span>
<span class="lineNum">     167 </span><span class="lineNoCov">          0 :                 st-&gt;tail = nel;</span>
<span class="lineNum">     168 </span>            :         }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineNoCov">          0 :         st-&gt;cur_ptr = nel;</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineNoCov">          0 :         return nel;</span>
<span class="lineNum">     173 </span>            : }
<a name="174"><span class="lineNum">     174 </span>            : </a>
<span class="lineNum">     175 </span>            : static struct _stack *
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : _new_stack(void) {</span>
<span class="lineNum">     177 </span><span class="lineNoCov">          0 :         return (struct _stack *)CALLOC(1, sizeof(struct _stack));</span>
<span class="lineNum">     178 </span>            : }
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : /*
<span class="lineNum">     181 </span>            :  * Decode OCTET STRING type.
<a name="182"><span class="lineNum">     182 </span>            :  */</a>
<span class="lineNum">     183 </span>            : asn_dec_rval_t
<span class="lineNum">     184 </span><span class="lineNoCov">          0 : OCTET_STRING_decode_ber(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">     185 </span>            :                         const asn_TYPE_descriptor_t *td, void **sptr,
<span class="lineNum">     186 </span>            :                         const void *buf_ptr, size_t size, int tag_mode) {
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :     const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">     188 </span>            :                                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">     189 </span><span class="lineNoCov">          0 :                                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">     190 </span><span class="lineNoCov">          0 :         BIT_STRING_t *st = (BIT_STRING_t *)*sptr;</span>
<span class="lineNum">     191 </span>            :         asn_dec_rval_t rval;
<span class="lineNum">     192 </span>            :         asn_struct_ctx_t *ctx;
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :         ssize_t consumed_myself = 0;</span>
<span class="lineNum">     194 </span>            :         struct _stack *stck;            /* Expectations stack structure */
<span class="lineNum">     195 </span><span class="lineNoCov">          0 :         struct _stack_el *sel = 0;      /* Stack element */</span>
<span class="lineNum">     196 </span>            :         int tlv_constr;
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         enum asn_OS_Subvariant type_variant = specs-&gt;subvariant;</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :         ASN_DEBUG(&quot;Decoding %s as %s (frame %ld)&quot;,
<span class="lineNum">     200 </span>            :                 td-&gt;name,
<span class="lineNum">     201 </span>            :                 (type_variant == ASN_OSUBV_STR) ?
<span class="lineNum">     202 </span>            :                         &quot;OCTET STRING&quot; : &quot;OS-SpecialCase&quot;,
<span class="lineNum">     203 </span>            :                 (long)size);
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :         /*
<span class="lineNum">     206 </span>            :          * Create the string if does not exist.
<span class="lineNum">     207 </span>            :          */
<span class="lineNum">     208 </span><span class="lineNoCov">          0 :         if(st == NULL) {</span>
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :                 st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs-&gt;struct_size));</span>
<span class="lineNum">     210 </span><span class="lineNoCov">          0 :                 if(st == NULL) RETURN(RC_FAIL);</span>
<span class="lineNum">     211 </span>            :         }
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :         /* Restore parsing context */
<span class="lineNum">     214 </span><span class="lineNoCov">          0 :         ctx = (asn_struct_ctx_t *)((char *)st + specs-&gt;ctx_offset);</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :         switch(ctx-&gt;phase) {</span>
<span class="lineNum">     217 </span>            :         case 0:
<span class="lineNum">     218 </span>            :                 /*
<span class="lineNum">     219 </span>            :                  * Check tags.
<span class="lineNum">     220 </span>            :                  */
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :                 rval = ber_check_tags(opt_codec_ctx, td, ctx,</span>
<span class="lineNum">     222 </span>            :                         buf_ptr, size, tag_mode, -1,
<span class="lineNum">     223 </span>            :                         &amp;ctx-&gt;left, &amp;tlv_constr);
<span class="lineNum">     224 </span><span class="lineNoCov">          0 :                 if(rval.code != RC_OK)</span>
<span class="lineNum">     225 </span><span class="lineNoCov">          0 :                         return rval;</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :                 if(tlv_constr) {</span>
<span class="lineNum">     228 </span>            :                         /*
<span class="lineNum">     229 </span>            :                          * Complex operation, requires stack of expectations.
<span class="lineNum">     230 </span>            :                          */
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :                         ctx-&gt;ptr = _new_stack();</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :                         if(!ctx-&gt;ptr) {</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">     234 </span>            :                         }
<span class="lineNum">     235 </span>            :                 } else {
<span class="lineNum">     236 </span>            :                         /*
<span class="lineNum">     237 </span>            :                          * Jump into stackless primitive decoding.
<span class="lineNum">     238 </span>            :                          */
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :                         _CH_PHASE(ctx, 3);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :                         if(type_variant == ASN_OSUBV_ANY &amp;&amp; tag_mode != 1)</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 :                                 APPEND(buf_ptr, rval.consumed);</span>
<span class="lineNum">     242 </span><span class="lineNoCov">          0 :                         ADVANCE(rval.consumed);</span>
<span class="lineNum">     243 </span><span class="lineNoCov">          0 :                         goto phase3;</span>
<span class="lineNum">     244 </span>            :                 }
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineNoCov">          0 :                 NEXT_PHASE(ctx);</span>
<span class="lineNum">     247 </span>            :                 /* Fall through */
<span class="lineNum">     248 </span>            :         case 1:
<span class="lineNum">     249 </span>            :         phase1:
<span class="lineNum">     250 </span>            :                 /*
<span class="lineNum">     251 </span>            :                  * Fill the stack with expectations.
<span class="lineNum">     252 </span>            :                  */
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :                 stck = (struct _stack *)ctx-&gt;ptr;</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                 sel = stck-&gt;cur_ptr;</span>
<span class="lineNum">     255 </span>            :           do {
<span class="lineNum">     256 </span>            :                 ber_tlv_tag_t tlv_tag;
<span class="lineNum">     257 </span>            :                 ber_tlv_len_t tlv_len;
<span class="lineNum">     258 </span>            :                 ber_tlv_tag_t expected_tag;
<span class="lineNum">     259 </span>            :                 ssize_t tl, ll, tlvl;
<span class="lineNum">     260 </span>            :                                 /* This one works even if (sel-&gt;left == -1) */
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :                 size_t Left = ((!sel||(size_t)sel-&gt;left &gt;= size)</span>
<span class="lineNum">     262 </span><span class="lineNoCov">          0 :                                         ?size:(size_t)sel-&gt;left);</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :                 ASN_DEBUG(&quot;%p, s-&gt;l=%ld, s-&gt;wn=%ld, s-&gt;g=%ld\n&quot;, (void *)sel,
<span class="lineNum">     266 </span>            :                         (long)(sel?sel-&gt;left:0),
<span class="lineNum">     267 </span>            :                         (long)(sel?sel-&gt;want_nulls:0),
<span class="lineNum">     268 </span>            :                         (long)(sel?sel-&gt;got:0)
<span class="lineNum">     269 </span>            :                 );
<span class="lineNum">     270 </span><span class="lineNoCov">          0 :                 if(sel &amp;&amp; sel-&gt;left &lt;= 0 &amp;&amp; sel-&gt;want_nulls == 0) {</span>
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :                         if(sel-&gt;prev) {</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :                                 struct _stack_el *prev = sel-&gt;prev;</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                                 if(prev-&gt;left != -1) {</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :                                         if(prev-&gt;left &lt; sel-&gt;got)</span>
<span class="lineNum">     275 </span><span class="lineNoCov">          0 :                                                 RETURN(RC_FAIL);</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 :                                         prev-&gt;left -= sel-&gt;got;</span>
<span class="lineNum">     277 </span>            :                                 }
<span class="lineNum">     278 </span><span class="lineNoCov">          0 :                                 prev-&gt;got += sel-&gt;got;</span>
<span class="lineNum">     279 </span><span class="lineNoCov">          0 :                                 sel = stck-&gt;cur_ptr = prev;</span>
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :                                 if(!sel) break;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :                                 tlv_constr = 1;</span>
<span class="lineNum">     282 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">     283 </span>            :                         } else {
<span class="lineNum">     284 </span><span class="lineNoCov">          0 :                                 sel = stck-&gt;cur_ptr = 0;</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :                                 break;  /* Nothing to wait */</span>
<span class="lineNum">     286 </span>            :                         }
<span class="lineNum">     287 </span>            :                 }
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :                 tl = ber_fetch_tag(buf_ptr, Left, &amp;tlv_tag);</span>
<span class="lineNum">     290 </span>            :                 ASN_DEBUG(&quot;fetch tag(size=%ld,L=%ld), %sstack, left=%ld, wn=%ld, tl=%ld&quot;,
<span class="lineNum">     291 </span>            :                         (long)size, (long)Left, sel?&quot;&quot;:&quot;!&quot;,
<span class="lineNum">     292 </span>            :                         (long)(sel?sel-&gt;left:0),
<span class="lineNum">     293 </span>            :                         (long)(sel?sel-&gt;want_nulls:0),
<span class="lineNum">     294 </span>            :                         (long)tl);
<span class="lineNum">     295 </span><span class="lineNoCov">          0 :                 switch(tl) {</span>
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :                 case -1: RETURN(RC_FAIL);</span>
<span class="lineNum">     297 </span><span class="lineNoCov">          0 :                 case 0: RETURN(RC_WMORE);</span>
<span class="lineNum">     298 </span>            :                 }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineNoCov">          0 :                 tlv_constr = BER_TLV_CONSTRUCTED(buf_ptr);</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineNoCov">          0 :                 ll = ber_fetch_length(tlv_constr,</span>
<span class="lineNum">     303 </span>            :                                 (const char *)buf_ptr + tl,Left - tl,&amp;tlv_len);
<span class="lineNum">     304 </span>            :                 ASN_DEBUG(&quot;Got tag=%s, tc=%d, left=%ld, tl=%ld, len=%ld, ll=%ld&quot;,
<span class="lineNum">     305 </span>            :                         ber_tlv_tag_string(tlv_tag), tlv_constr,
<span class="lineNum">     306 </span>            :                                 (long)Left, (long)tl, (long)tlv_len, (long)ll);
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :                 switch(ll) {</span>
<span class="lineNum">     308 </span><span class="lineNoCov">          0 :                 case -1: RETURN(RC_FAIL);</span>
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :                 case 0: RETURN(RC_WMORE);</span>
<span class="lineNum">     310 </span>            :                 }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span><span class="lineNoCov">          0 :                 if(sel &amp;&amp; sel-&gt;want_nulls</span>
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :                         &amp;&amp; ((const uint8_t *)buf_ptr)[0] == 0</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :                         &amp;&amp; ((const uint8_t *)buf_ptr)[1] == 0)</span>
<span class="lineNum">     315 </span>            :                 {
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :                         ASN_DEBUG(&quot;Eat EOC; wn=%d--&quot;, sel-&gt;want_nulls);
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :                         if(type_variant == ASN_OSUBV_ANY</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :                         &amp;&amp; (tag_mode != 1 || sel-&gt;cont_level))</span>
<span class="lineNum">     321 </span><span class="lineNoCov">          0 :                                 APPEND(&quot;\0\0&quot;, 2);</span>
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineNoCov">          0 :                         ADVANCE(2);</span>
<span class="lineNum">     324 </span><span class="lineNoCov">          0 :                         sel-&gt;got += 2;</span>
<span class="lineNum">     325 </span><span class="lineNoCov">          0 :                         if(sel-&gt;left != -1) {</span>
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :                                 sel-&gt;left -= 2;      /* assert(sel-&gt;left &gt;= 2) */</span>
<span class="lineNum">     327 </span>            :                         }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :                         sel-&gt;want_nulls--;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :                         if(sel-&gt;want_nulls == 0) {</span>
<span class="lineNum">     331 </span>            :                                 /* Move to the next expectation */
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :                                 sel-&gt;left = 0;</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :                                 tlv_constr = 1;</span>
<span class="lineNum">     334 </span>            :                         }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     337 </span>            :                 }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            :                 /*
<span class="lineNum">     340 </span>            :                  * Set up expected tags,
<span class="lineNum">     341 </span>            :                  * depending on ASN.1 type being decoded.
<span class="lineNum">     342 </span>            :                  */
<span class="lineNum">     343 </span><span class="lineNoCov">          0 :                 switch(type_variant) {</span>
<span class="lineNum">     344 </span>            :                 case ASN_OSUBV_BIT:
<span class="lineNum">     345 </span>            :                         /* X.690: 8.6.4.1, NOTE 2 */
<span class="lineNum">     346 </span>            :                         /* Fall through */
<span class="lineNum">     347 </span>            :                 case ASN_OSUBV_STR:
<span class="lineNum">     348 </span>            :                 default:
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                         if(sel) {</span>
<span class="lineNum">     350 </span><span class="lineNoCov">          0 :                                 unsigned level = sel-&gt;cont_level;</span>
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :                                 if(level &lt; td-&gt;all_tags_count) {</span>
<span class="lineNum">     352 </span><span class="lineNoCov">          0 :                                         expected_tag = td-&gt;all_tags[level];</span>
<span class="lineNum">     353 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">     354 </span><span class="lineNoCov">          0 :                                 } else if(td-&gt;all_tags_count) {</span>
<span class="lineNum">     355 </span><span class="lineNoCov">          0 :                                         expected_tag = td-&gt;all_tags</span>
<span class="lineNum">     356 </span><span class="lineNoCov">          0 :                                                 [td-&gt;all_tags_count - 1];</span>
<span class="lineNum">     357 </span><span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">     358 </span>            :                                 }
<span class="lineNum">     359 </span>            :                                 /* else, Fall through */
<span class="lineNum">     360 </span>            :                         }
<span class="lineNum">     361 </span>            :                         /* Fall through */
<span class="lineNum">     362 </span>            :                 case ASN_OSUBV_ANY:
<span class="lineNum">     363 </span><span class="lineNoCov">          0 :                         expected_tag = tlv_tag;</span>
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     365 </span>            :                 }
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :                 if(tlv_tag != expected_tag) {</span>
<span class="lineNum">     369 </span>            :                         char buf[2][32];
<span class="lineNum">     370 </span><span class="lineNoCov">          0 :                         ber_tlv_tag_snprint(tlv_tag,</span>
<span class="lineNum">     371 </span>            :                                 buf[0], sizeof(buf[0]));
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :                         ber_tlv_tag_snprint(td-&gt;tags[td-&gt;tags_count-1],</span>
<span class="lineNum">     373 </span>            :                                 buf[1], sizeof(buf[1]));
<span class="lineNum">     374 </span>            :                         ASN_DEBUG(&quot;Tag does not match expectation: %s != %s&quot;,
<span class="lineNum">     375 </span>            :                                 buf[0], buf[1]);
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :                         RETURN(RC_FAIL);</span>
<span class="lineNum">     377 </span>            :                 }
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineNoCov">          0 :                 tlvl = tl + ll; /* Combined length of T and L encoding */</span>
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :                 if((tlv_len + tlvl) &lt; 0) {</span>
<span class="lineNum">     381 </span>            :                         /* tlv_len value is too big */
<span class="lineNum">     382 </span>            :                         ASN_DEBUG(&quot;TLV encoding + length (%ld) is too big&quot;,
<span class="lineNum">     383 </span>            :                                 (long)tlv_len);
<span class="lineNum">     384 </span><span class="lineNoCov">          0 :                         RETURN(RC_FAIL);</span>
<span class="lineNum">     385 </span>            :                 }
<span class="lineNum">     386 </span>            : 
<span class="lineNum">     387 </span>            :                 /*
<span class="lineNum">     388 </span>            :                  * Append a new expectation.
<span class="lineNum">     389 </span>            :                  */
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :                 sel = OS__add_stack_el(stck);</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :                 if(!sel) RETURN(RC_FAIL);</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :                 sel-&gt;tag = tlv_tag;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineNoCov">          0 :                 sel-&gt;want_nulls = (tlv_len==-1);</span>
<span class="lineNum">     396 </span><span class="lineNoCov">          0 :                 if(sel-&gt;prev &amp;&amp; sel-&gt;prev-&gt;left != -1) {</span>
<span class="lineNum">     397 </span>            :                         /* Check that the parent frame is big enough */
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :                         if(sel-&gt;prev-&gt;left &lt; tlvl + (tlv_len==-1?0:tlv_len))</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">     400 </span><span class="lineNoCov">          0 :                         if(tlv_len == -1)</span>
<span class="lineNum">     401 </span><span class="lineNoCov">          0 :                                 sel-&gt;left = sel-&gt;prev-&gt;left - tlvl;</span>
<span class="lineNum">     402 </span>            :                         else
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :                                 sel-&gt;left = tlv_len;</span>
<span class="lineNum">     404 </span>            :                 } else {
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :                         sel-&gt;left = tlv_len;</span>
<span class="lineNum">     406 </span>            :                 }
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :                 if(type_variant == ASN_OSUBV_ANY</span>
<span class="lineNum">     408 </span><span class="lineNoCov">          0 :                 &amp;&amp; (tag_mode != 1 || sel-&gt;cont_level))</span>
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :                         APPEND(buf_ptr, tlvl);</span>
<span class="lineNum">     410 </span><span class="lineNoCov">          0 :                 sel-&gt;got += tlvl;</span>
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :                 ADVANCE(tlvl);</span>
<span class="lineNum">     412 </span>            : 
<span class="lineNum">     413 </span>            :                 ASN_DEBUG(&quot;+EXPECT2 got=%ld left=%ld, wn=%d, clvl=%u&quot;,
<span class="lineNum">     414 </span>            :                         (long)sel-&gt;got, (long)sel-&gt;left,
<span class="lineNum">     415 </span>            :                         sel-&gt;want_nulls, sel-&gt;cont_level);
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :           } while(tlv_constr);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :                 if(sel == NULL) {</span>
<span class="lineNum">     419 </span>            :                         /* Finished operation, &quot;phase out&quot; */
<span class="lineNum">     420 </span>            :                         ASN_DEBUG(&quot;Phase out&quot;);
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :                         _CH_PHASE(ctx, +3);</span>
<span class="lineNum">     422 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     423 </span>            :                 }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :                 NEXT_PHASE(ctx);</span>
<span class="lineNum">     426 </span>            :                 /* Fall through */
<span class="lineNum">     427 </span>            :         case 2:
<span class="lineNum">     428 </span><span class="lineNoCov">          0 :                 stck = (struct _stack *)ctx-&gt;ptr;</span>
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :                 sel = stck-&gt;cur_ptr;</span>
<span class="lineNum">     430 </span>            :                 ASN_DEBUG(&quot;Phase 2: Need %ld bytes, size=%ld, alrg=%ld, wn=%d&quot;,
<span class="lineNum">     431 </span>            :                         (long)sel-&gt;left, (long)size, (long)sel-&gt;got,
<span class="lineNum">     432 </span>            :                                 sel-&gt;want_nulls);
<span class="lineNum">     433 </span>            :             {
<span class="lineNum">     434 </span>            :                 ber_tlv_len_t len;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :                 assert(sel-&gt;left &gt;= 0);</span>
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :                 len = ((ber_tlv_len_t)size &lt; sel-&gt;left)</span>
<span class="lineNum">     439 </span><span class="lineNoCov">          0 :                                 ? (ber_tlv_len_t)size : sel-&gt;left;</span>
<span class="lineNum">     440 </span><span class="lineNoCov">          0 :                 if(len &gt; 0) {</span>
<span class="lineNum">     441 </span><span class="lineNoCov">          0 :                         if(type_variant == ASN_OSUBV_BIT</span>
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :                         &amp;&amp; sel-&gt;bits_chopped == 0) {</span>
<span class="lineNum">     443 </span>            :                                 /* Put the unused-bits-octet away */
<span class="lineNum">     444 </span><span class="lineNoCov">          0 :                                 st-&gt;bits_unused = *(const uint8_t *)buf_ptr;</span>
<span class="lineNum">     445 </span><span class="lineNoCov">          0 :                                 APPEND(((const char *)buf_ptr+1), (len - 1));</span>
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :                                 sel-&gt;bits_chopped = 1;</span>
<span class="lineNum">     447 </span>            :                         } else {
<span class="lineNum">     448 </span><span class="lineNoCov">          0 :                                 APPEND(buf_ptr, len);</span>
<span class="lineNum">     449 </span>            :                         }
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :                         ADVANCE(len);</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :                         sel-&gt;left -= len;</span>
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :                         sel-&gt;got += len;</span>
<span class="lineNum">     453 </span>            :                 }
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :                 if(sel-&gt;left) {</span>
<span class="lineNum">     456 </span>            :                         ASN_DEBUG(&quot;OS left %ld, size = %ld, wn=%d\n&quot;,
<span class="lineNum">     457 </span>            :                                 (long)sel-&gt;left, (long)size, sel-&gt;want_nulls);
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :                         RETURN(RC_WMORE);</span>
<span class="lineNum">     459 </span>            :                 }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :                 PREV_PHASE(ctx);</span>
<span class="lineNum">     462 </span><span class="lineNoCov">          0 :                 goto phase1;</span>
<span class="lineNum">     463 </span>            :             }
<span class="lineNum">     464 </span>            :                 break;
<span class="lineNum">     465 </span>            :         case 3:
<span class="lineNum">     466 </span>            :         phase3:
<span class="lineNum">     467 </span>            :                 /*
<span class="lineNum">     468 </span>            :                  * Primitive form, no stack required.
<span class="lineNum">     469 </span>            :                  */
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :                 assert(ctx-&gt;left &gt;= 0);</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :                 if(size &lt; (size_t)ctx-&gt;left) {</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :                         if(!size) RETURN(RC_WMORE);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :                         if(type_variant == ASN_OSUBV_BIT &amp;&amp; !ctx-&gt;context) {</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :                                 st-&gt;bits_unused = *(const uint8_t *)buf_ptr;</span>
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :                                 ctx-&gt;left--;</span>
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :                                 ADVANCE(1);</span>
<span class="lineNum">     478 </span>            :                         }
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :                         APPEND(buf_ptr, size);</span>
<span class="lineNum">     480 </span><span class="lineNoCov">          0 :                         assert(ctx-&gt;context &gt; 0);</span>
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :                         ctx-&gt;left -= size;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :                         ADVANCE(size);</span>
<span class="lineNum">     483 </span><span class="lineNoCov">          0 :                         RETURN(RC_WMORE);</span>
<span class="lineNum">     484 </span>            :                 } else {
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :                         if(type_variant == ASN_OSUBV_BIT</span>
<span class="lineNum">     486 </span><span class="lineNoCov">          0 :                         &amp;&amp; !ctx-&gt;context &amp;&amp; ctx-&gt;left) {</span>
<span class="lineNum">     487 </span><span class="lineNoCov">          0 :                                 st-&gt;bits_unused = *(const uint8_t *)buf_ptr;</span>
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :                                 ctx-&gt;left--;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :                                 ADVANCE(1);</span>
<span class="lineNum">     490 </span>            :                         }
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :                         APPEND(buf_ptr, ctx-&gt;left);</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :                         ADVANCE(ctx-&gt;left);</span>
<span class="lineNum">     493 </span><span class="lineNoCov">          0 :                         ctx-&gt;left = 0;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :                         NEXT_PHASE(ctx);</span>
<span class="lineNum">     496 </span>            :                 }
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     498 </span>            :         }
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineNoCov">          0 :         if(sel) {</span>
<span class="lineNum">     501 </span>            :                 ASN_DEBUG(&quot;3sel p=%p, wn=%d, l=%ld, g=%ld, size=%ld&quot;,
<span class="lineNum">     502 </span>            :                         (void *)sel-&gt;prev, sel-&gt;want_nulls,
<span class="lineNum">     503 </span>            :                         (long)sel-&gt;left, (long)sel-&gt;got, (long)size);
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :                 if(sel-&gt;prev || sel-&gt;want_nulls &gt; 1 || sel-&gt;left &gt; 0) {</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :                         RETURN(RC_WMORE);</span>
<span class="lineNum">     506 </span>            :                 }
<span class="lineNum">     507 </span>            :         }
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :         /*
<span class="lineNum">     510 </span>            :          * BIT STRING-specific processing.
<span class="lineNum">     511 </span>            :          */
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         if(type_variant == ASN_OSUBV_BIT) {</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :         if(st-&gt;size) {</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :                         if(st-&gt;bits_unused &lt; 0 || st-&gt;bits_unused &gt; 7) {</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">     516 </span>            :                         }
<span class="lineNum">     517 </span>            :                         /* Finalize BIT STRING: zero out unused bits. */
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :                         st-&gt;buf[st-&gt;size-1] &amp;= 0xff &lt;&lt; st-&gt;bits_unused;</span>
<span class="lineNum">     519 </span>            :                 } else {
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :                         if(st-&gt;bits_unused) {</span>
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">     522 </span>            :                         }
<span class="lineNum">     523 </span>            :                 }
<span class="lineNum">     524 </span>            :         }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            :         ASN_DEBUG(&quot;Took %ld bytes to encode %s: [%s]:%ld&quot;,
<span class="lineNum">     527 </span>            :                 (long)consumed_myself, td-&gt;name,
<span class="lineNum">     528 </span>            :                 (type_variant == ASN_OSUBV_STR) ? (char *)st-&gt;buf : &quot;&lt;data&gt;&quot;,
<span class="lineNum">     529 </span>            :                 (long)st-&gt;size);
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :         RETURN(RC_OK);</span>
<span class="lineNum">     533 </span>            : }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            : /*
<span class="lineNum">     536 </span>            :  * Encode OCTET STRING type using DER.
<a name="537"><span class="lineNum">     537 </span>            :  */</a>
<span class="lineNum">     538 </span>            : asn_enc_rval_t
<span class="lineNum">     539 </span><span class="lineNoCov">          0 : OCTET_STRING_encode_der(const asn_TYPE_descriptor_t *td, const void *sptr,</span>
<span class="lineNum">     540 </span>            :                         int tag_mode, ber_tlv_tag_t tag,
<span class="lineNum">     541 </span>            :                         asn_app_consume_bytes_f *cb, void *app_key) {
<span class="lineNum">     542 </span>            :     asn_enc_rval_t er;
<span class="lineNum">     543 </span><span class="lineNoCov">          0 :         const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">     544 </span>            :                                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">     545 </span><span class="lineNoCov">          0 :                                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :         const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;</span>
<span class="lineNum">     547 </span><span class="lineNoCov">          0 :         enum asn_OS_Subvariant type_variant = specs-&gt;subvariant;</span>
<span class="lineNum">     548 </span><span class="lineNoCov">          0 :         int fix_last_byte = 0;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :         ASN_DEBUG(&quot;%s %s as OCTET STRING&quot;,
<span class="lineNum">     551 </span>            :                 cb?&quot;Estimating&quot;:&quot;Encoding&quot;, td-&gt;name);
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :         /*
<span class="lineNum">     554 </span>            :          * Write tags.
<span class="lineNum">     555 </span>            :          */
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :         if(type_variant != ASN_OSUBV_ANY || tag_mode == 1) {</span>
<span class="lineNum">     557 </span><span class="lineNoCov">          0 :                 er.encoded = der_write_tags(td,</span>
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :                                 (type_variant == ASN_OSUBV_BIT) + st-&gt;size,</span>
<span class="lineNum">     559 </span>            :                         tag_mode, type_variant == ASN_OSUBV_ANY, tag,
<span class="lineNum">     560 </span>            :                         cb, app_key);
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :                 if(er.encoded == -1) {</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :                         er.failed_type = td;</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :                         er.structure_ptr = sptr;</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :                         return er;</span>
<span class="lineNum">     565 </span>            :                 }
<span class="lineNum">     566 </span>            :         } else {
<span class="lineNum">     567 </span>            :                 /* Disallow: [&lt;tag&gt;] IMPLICIT ANY */
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :                 assert(type_variant != ASN_OSUBV_ANY || tag_mode != -1);</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :                 er.encoded = 0;</span>
<span class="lineNum">     570 </span>            :         }
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineNoCov">          0 :         if(!cb) {</span>
<span class="lineNum">     573 </span><span class="lineNoCov">          0 :                 er.encoded += (type_variant == ASN_OSUBV_BIT) + st-&gt;size;</span>
<span class="lineNum">     574 </span><span class="lineNoCov">          0 :                 ASN__ENCODED_OK(er);</span>
<span class="lineNum">     575 </span>            :         }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :         /*
<span class="lineNum">     578 </span>            :          * Prepare to deal with the last octet of BIT STRING.
<span class="lineNum">     579 </span>            :          */
<span class="lineNum">     580 </span><span class="lineNoCov">          0 :         if(type_variant == ASN_OSUBV_BIT) {</span>
<span class="lineNum">     581 </span><span class="lineNoCov">          0 :                 uint8_t b = st-&gt;bits_unused &amp; 0x07;</span>
<span class="lineNum">     582 </span><span class="lineNoCov">          0 :                 if(b &amp;&amp; st-&gt;size) fix_last_byte = 1;</span>
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :                 ASN__CALLBACK(&amp;b, 1);</span>
<span class="lineNum">     584 </span>            :         }
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            :         /* Invoke callback for the main part of the buffer */
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :         ASN__CALLBACK(st-&gt;buf, st-&gt;size - fix_last_byte);</span>
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span>            :         /* The last octet should be stripped off the unused bits */
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :         if(fix_last_byte) {</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :                 uint8_t b = st-&gt;buf[st-&gt;size-1] &amp; (0xff &lt;&lt; st-&gt;bits_unused);</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :                 ASN__CALLBACK(&amp;b, 1);</span>
<span class="lineNum">     593 </span>            :         }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :         ASN__ENCODED_OK(er);</span>
<span class="lineNum">     596 </span>            : cb_failed:
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :         ASN__ENCODE_FAILED;</span>
<span class="lineNum">     598 </span>            : }
<a name="599"><span class="lineNum">     599 </span>            : </a>
<span class="lineNum">     600 </span>            : asn_enc_rval_t
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : OCTET_STRING_encode_xer(const asn_TYPE_descriptor_t *td, const void *sptr,</span>
<span class="lineNum">     602 </span>            :                         int ilevel, enum xer_encoder_flags_e flags,
<span class="lineNum">     603 </span>            :                         asn_app_consume_bytes_f *cb, void *app_key) {
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     const char * const h2c = &quot;0123456789ABCDEF&quot;;</span>
<span class="lineNum">     605 </span><span class="lineNoCov">          0 :         const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;</span>
<span class="lineNum">     606 </span>            :         asn_enc_rval_t er;
<span class="lineNum">     607 </span>            :         char scratch[16 * 3 + 4];
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :         char *p = scratch;</span>
<span class="lineNum">     609 </span>            :         uint8_t *buf;
<span class="lineNum">     610 </span>            :         uint8_t *end;
<span class="lineNum">     611 </span>            :         size_t i;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :         if(!st || (!st-&gt;buf &amp;&amp; st-&gt;size))</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineNoCov">          0 :         er.encoded = 0;</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            :         /*
<span class="lineNum">     619 </span>            :          * Dump the contents of the buffer in hexadecimal.
<span class="lineNum">     620 </span>            :          */
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :         end = buf + st-&gt;size;</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :         if(flags &amp; XER_F_CANONICAL) {</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :                 char *scend = scratch + (sizeof(scratch) - 2);</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :                 for(; buf &lt; end; buf++) {</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :                         if(p &gt;= scend) {</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :                                 ASN__CALLBACK(scratch, p - scratch);</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :                                 p = scratch;</span>
<span class="lineNum">     629 </span>            :                         }
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :                         *p++ = h2c[(*buf &gt;&gt; 4) &amp; 0x0F];</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :                         *p++ = h2c[*buf &amp; 0x0F];</span>
<span class="lineNum">     632 </span>            :                 }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :                 ASN__CALLBACK(scratch, p-scratch);      /* Dump the rest */</span>
<span class="lineNum">     635 </span>            :         } else {
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :                 for(i = 0; buf &lt; end; buf++, i++) {</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :                         if(!(i % 16) &amp;&amp; (i || st-&gt;size &gt; 16)) {</span>
<span class="lineNum">     638 </span><span class="lineNoCov">          0 :                                 ASN__CALLBACK(scratch, p-scratch);</span>
<span class="lineNum">     639 </span><span class="lineNoCov">          0 :                                 p = scratch;</span>
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :                                 ASN__TEXT_INDENT(1, ilevel);</span>
<span class="lineNum">     641 </span>            :                         }
<span class="lineNum">     642 </span><span class="lineNoCov">          0 :                         *p++ = h2c[(*buf &gt;&gt; 4) &amp; 0x0F];</span>
<span class="lineNum">     643 </span><span class="lineNoCov">          0 :                         *p++ = h2c[*buf &amp; 0x0F];</span>
<span class="lineNum">     644 </span><span class="lineNoCov">          0 :                         *p++ = 0x20;</span>
<span class="lineNum">     645 </span>            :                 }
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :                 if(p - scratch) {</span>
<span class="lineNum">     647 </span><span class="lineNoCov">          0 :                         p--;    /* Remove the tail space */</span>
<span class="lineNum">     648 </span><span class="lineNoCov">          0 :                         ASN__CALLBACK(scratch, p-scratch); /* Dump the rest */</span>
<span class="lineNum">     649 </span><span class="lineNoCov">          0 :                         if(st-&gt;size &gt; 16)</span>
<span class="lineNum">     650 </span><span class="lineNoCov">          0 :                                 ASN__TEXT_INDENT(1, ilevel-1);</span>
<span class="lineNum">     651 </span>            :                 }
<span class="lineNum">     652 </span>            :         }
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :         ASN__ENCODED_OK(er);</span>
<span class="lineNum">     655 </span>            : cb_failed:
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :         ASN__ENCODE_FAILED;</span>
<span class="lineNum">     657 </span>            : }
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : static const struct OCTET_STRING__xer_escape_table_s {
<span class="lineNum">     660 </span>            :         const char *string;
<span class="lineNum">     661 </span>            :         int size;
<span class="lineNum">     662 </span>            : } OCTET_STRING__xer_escape_table[] = {
<span class="lineNum">     663 </span>            : #define OSXET(s)        { s, sizeof(s) - 1 }
<span class="lineNum">     664 </span>            :         OSXET(&quot;\074\156\165\154\057\076&quot;),    /* &lt;nul/&gt; */
<span class="lineNum">     665 </span>            :         OSXET(&quot;\074\163\157\150\057\076&quot;),    /* &lt;soh/&gt; */
<span class="lineNum">     666 </span>            :         OSXET(&quot;\074\163\164\170\057\076&quot;),    /* &lt;stx/&gt; */
<span class="lineNum">     667 </span>            :         OSXET(&quot;\074\145\164\170\057\076&quot;),    /* &lt;etx/&gt; */
<span class="lineNum">     668 </span>            :         OSXET(&quot;\074\145\157\164\057\076&quot;),    /* &lt;eot/&gt; */
<span class="lineNum">     669 </span>            :         OSXET(&quot;\074\145\156\161\057\076&quot;),    /* &lt;enq/&gt; */
<span class="lineNum">     670 </span>            :         OSXET(&quot;\074\141\143\153\057\076&quot;),    /* &lt;ack/&gt; */
<span class="lineNum">     671 </span>            :         OSXET(&quot;\074\142\145\154\057\076&quot;),    /* &lt;bel/&gt; */
<span class="lineNum">     672 </span>            :         OSXET(&quot;\074\142\163\057\076&quot;),                /* &lt;bs/&gt; */
<span class="lineNum">     673 </span>            :         OSXET(&quot;\011&quot;),                                /* \t */
<span class="lineNum">     674 </span>            :         OSXET(&quot;\012&quot;),                                /* \n */
<span class="lineNum">     675 </span>            :         OSXET(&quot;\074\166\164\057\076&quot;),                /* &lt;vt/&gt; */
<span class="lineNum">     676 </span>            :         OSXET(&quot;\074\146\146\057\076&quot;),                /* &lt;ff/&gt; */
<span class="lineNum">     677 </span>            :         OSXET(&quot;\015&quot;),                                /* \r */
<span class="lineNum">     678 </span>            :         OSXET(&quot;\074\163\157\057\076&quot;),                /* &lt;so/&gt; */
<span class="lineNum">     679 </span>            :         OSXET(&quot;\074\163\151\057\076&quot;),                /* &lt;si/&gt; */
<span class="lineNum">     680 </span>            :         OSXET(&quot;\074\144\154\145\057\076&quot;),    /* &lt;dle/&gt; */
<span class="lineNum">     681 </span>            :         OSXET(&quot;\074\144\143\061\057\076&quot;),    /* &lt;de1/&gt; */
<span class="lineNum">     682 </span>            :         OSXET(&quot;\074\144\143\062\057\076&quot;),    /* &lt;de2/&gt; */
<span class="lineNum">     683 </span>            :         OSXET(&quot;\074\144\143\063\057\076&quot;),    /* &lt;de3/&gt; */
<span class="lineNum">     684 </span>            :         OSXET(&quot;\074\144\143\064\057\076&quot;),    /* &lt;de4/&gt; */
<span class="lineNum">     685 </span>            :         OSXET(&quot;\074\156\141\153\057\076&quot;),    /* &lt;nak/&gt; */
<span class="lineNum">     686 </span>            :         OSXET(&quot;\074\163\171\156\057\076&quot;),    /* &lt;syn/&gt; */
<span class="lineNum">     687 </span>            :         OSXET(&quot;\074\145\164\142\057\076&quot;),    /* &lt;etb/&gt; */
<span class="lineNum">     688 </span>            :         OSXET(&quot;\074\143\141\156\057\076&quot;),    /* &lt;can/&gt; */
<span class="lineNum">     689 </span>            :         OSXET(&quot;\074\145\155\057\076&quot;),                /* &lt;em/&gt; */
<span class="lineNum">     690 </span>            :         OSXET(&quot;\074\163\165\142\057\076&quot;),    /* &lt;sub/&gt; */
<span class="lineNum">     691 </span>            :         OSXET(&quot;\074\145\163\143\057\076&quot;),    /* &lt;esc/&gt; */
<span class="lineNum">     692 </span>            :         OSXET(&quot;\074\151\163\064\057\076&quot;),    /* &lt;is4/&gt; */
<span class="lineNum">     693 </span>            :         OSXET(&quot;\074\151\163\063\057\076&quot;),    /* &lt;is3/&gt; */
<span class="lineNum">     694 </span>            :         OSXET(&quot;\074\151\163\062\057\076&quot;),    /* &lt;is2/&gt; */
<span class="lineNum">     695 </span>            :         OSXET(&quot;\074\151\163\061\057\076&quot;),    /* &lt;is1/&gt; */
<span class="lineNum">     696 </span>            :         { 0, 0 },       /* &quot; &quot; */
<span class="lineNum">     697 </span>            :         { 0, 0 },       /* ! */
<span class="lineNum">     698 </span>            :         { 0, 0 },       /* \&quot; */
<span class="lineNum">     699 </span>            :         { 0, 0 },       /* # */
<span class="lineNum">     700 </span>            :         { 0, 0 },       /* $ */
<span class="lineNum">     701 </span>            :         { 0, 0 },       /* % */
<span class="lineNum">     702 </span>            :         OSXET(&quot;\046\141\155\160\073&quot;),        /* &amp;amp; */
<span class="lineNum">     703 </span>            :         { 0, 0 },       /* ' */
<span class="lineNum">     704 </span>            :         {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, /* ()*+,-./ */
<span class="lineNum">     705 </span>            :         {0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}, /* 01234567 */
<span class="lineNum">     706 </span>            :         {0,0},{0,0},{0,0},{0,0},                         /* 89:; */
<span class="lineNum">     707 </span>            :         OSXET(&quot;\046\154\164\073&quot;),    /* &amp;lt; */
<span class="lineNum">     708 </span>            :         { 0, 0 },       /* = */
<span class="lineNum">     709 </span>            :         OSXET(&quot;\046\147\164\073&quot;),    /* &amp;gt; */
<span class="lineNum">     710 </span>            : };
<a name="711"><span class="lineNum">     711 </span>            : </a>
<span class="lineNum">     712 </span>            : static int
<span class="lineNum">     713 </span><span class="lineNoCov">          0 : OS__check_escaped_control_char(const void *buf, int size) {</span>
<span class="lineNum">     714 </span>            :         size_t i;
<span class="lineNum">     715 </span>            :         /*
<span class="lineNum">     716 </span>            :          * Inefficient algorithm which translates the escape sequences
<span class="lineNum">     717 </span>            :          * defined above into characters. Returns -1 if not found.
<span class="lineNum">     718 </span>            :          * TODO: replace by a faster algorithm (bsearch(), hash or
<span class="lineNum">     719 </span>            :          * nested table lookups).
<span class="lineNum">     720 </span>            :          */
<span class="lineNum">     721 </span><span class="lineNoCov">          0 :         for(i = 0; i &lt; 32 /* Don't spend time on the bottom half */; i++) {</span>
<span class="lineNum">     722 </span>            :                 const struct OCTET_STRING__xer_escape_table_s *el;
<span class="lineNum">     723 </span><span class="lineNoCov">          0 :                 el = &amp;OCTET_STRING__xer_escape_table[i];</span>
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :                 if(el-&gt;size == size &amp;&amp; memcmp(buf, el-&gt;string, size) == 0)</span>
<span class="lineNum">     725 </span><span class="lineNoCov">          0 :                         return i;</span>
<span class="lineNum">     726 </span>            :         }
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">     728 </span>            : }
<a name="729"><span class="lineNum">     729 </span>            : </a>
<span class="lineNum">     730 </span>            : static int
<span class="lineNum">     731 </span><span class="lineNoCov">          0 : OCTET_STRING__handle_control_chars(void *struct_ptr, const void *chunk_buf, size_t chunk_size) {</span>
<span class="lineNum">     732 </span>            :         /*
<span class="lineNum">     733 </span>            :          * This might be one of the escape sequences
<span class="lineNum">     734 </span>            :          * for control characters. Check it out.
<span class="lineNum">     735 </span>            :          * #11.15.5
<span class="lineNum">     736 </span>            :          */
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :         int control_char = OS__check_escaped_control_char(chunk_buf,chunk_size);</span>
<span class="lineNum">     738 </span><span class="lineNoCov">          0 :         if(control_char &gt;= 0) {</span>
<span class="lineNum">     739 </span><span class="lineNoCov">          0 :                 OCTET_STRING_t *st = (OCTET_STRING_t *)struct_ptr;</span>
<span class="lineNum">     740 </span><span class="lineNoCov">          0 :                 void *p = REALLOC(st-&gt;buf, st-&gt;size + 2);</span>
<span class="lineNum">     741 </span><span class="lineNoCov">          0 :                 if(p) {</span>
<span class="lineNum">     742 </span><span class="lineNoCov">          0 :                         st-&gt;buf = (uint8_t *)p;</span>
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :                         st-&gt;buf[st-&gt;size++] = control_char;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                         st-&gt;buf[st-&gt;size] = '\0'; /* nul-termination */</span>
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :                         return 0;</span>
<span class="lineNum">     746 </span>            :                 }
<span class="lineNum">     747 </span>            :         }
<span class="lineNum">     748 </span>            :         
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :         return -1;      /* No, it's not */</span>
<span class="lineNum">     750 </span>            : }
<a name="751"><span class="lineNum">     751 </span>            : </a>
<span class="lineNum">     752 </span>            : asn_enc_rval_t
<span class="lineNum">     753 </span><span class="lineNoCov">          0 : OCTET_STRING_encode_xer_utf8(const asn_TYPE_descriptor_t *td, const void *sptr,</span>
<span class="lineNum">     754 </span>            :                              int ilevel, enum xer_encoder_flags_e flags,
<span class="lineNum">     755 </span>            :                              asn_app_consume_bytes_f *cb, void *app_key) {
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :     const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;</span>
<span class="lineNum">     757 </span>            :         asn_enc_rval_t er;
<span class="lineNum">     758 </span>            :         uint8_t *buf, *end;
<span class="lineNum">     759 </span>            :         uint8_t *ss;    /* Sequence start */
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :         ssize_t encoded_len = 0;</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :         (void)ilevel;   /* Unused argument */
<span class="lineNum">     763 </span>            :         (void)flags;    /* Unused argument */
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :         if(!st || (!st-&gt;buf &amp;&amp; st-&gt;size))</span>
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf;</span>
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :         end = buf + st-&gt;size;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :         for(ss = buf; buf &lt; end; buf++) {</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :                 unsigned int ch = *buf;</span>
<span class="lineNum">     772 </span>            :                 int s_len;      /* Special encoding sequence length */
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :                 /*
<span class="lineNum">     775 </span>            :                  * Escape certain characters: X.680/11.15
<span class="lineNum">     776 </span>            :                  */
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :                 if(ch &lt; sizeof(OCTET_STRING__xer_escape_table)</span>
<span class="lineNum">     778 </span>            :                         /sizeof(OCTET_STRING__xer_escape_table[0])
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :                 &amp;&amp; (s_len = OCTET_STRING__xer_escape_table[ch].size)) {</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :                         if(((buf - ss) &amp;&amp; cb(ss, buf - ss, app_key) &lt; 0)</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :                         || cb(OCTET_STRING__xer_escape_table[ch].string, s_len,</span>
<span class="lineNum">     782 </span>            :                                         app_key) &lt; 0)
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :                                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :                         encoded_len += (buf - ss) + s_len;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :                         ss = buf + 1;</span>
<span class="lineNum">     786 </span>            :                 }
<span class="lineNum">     787 </span>            :         }
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :         encoded_len += (buf - ss);</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :         if((buf - ss) &amp;&amp; cb(ss, buf - ss, app_key) &lt; 0)</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :         er.encoded = encoded_len;</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :         ASN__ENCODED_OK(er);</span>
<span class="lineNum">     795 </span>            : }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : /*
<a name="798"><span class="lineNum">     798 </span>            :  * Convert from hexadecimal format (cstring): &quot;AB CD EF&quot;</a>
<span class="lineNum">     799 </span>            :  */
<span class="lineNum">     800 </span><span class="lineNoCov">          0 : static ssize_t OCTET_STRING__convert_hexadecimal(void *sptr, const void *chunk_buf, size_t chunk_size, int have_more) {</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :         OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :         const char *chunk_stop = (const char *)chunk_buf;</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :         const char *p = chunk_stop;</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :         const char *pend = p + chunk_size;</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :         unsigned int clv = 0;</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :         int half = 0;   /* Half bit */</span>
<span class="lineNum">     807 </span>            :         uint8_t *buf;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :         /* Reallocate buffer according to high cap estimation */
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :         size_t new_size = st-&gt;size + (chunk_size + 1) / 2;</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :         void *nptr = REALLOC(st-&gt;buf, new_size + 1);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :         if(!nptr) return -1;</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :         st-&gt;buf = (uint8_t *)nptr;</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf + st-&gt;size;</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :         /*
<span class="lineNum">     817 </span>            :          * If something like &quot; a b c &quot; appears here, the &quot; a b&quot;:3 will be
<span class="lineNum">     818 </span>            :          * converted, and the rest skipped. That is, unless buf_size is greater
<span class="lineNum">     819 </span>            :          * than chunk_size, then it'll be equivalent to &quot;ABC0&quot;.
<span class="lineNum">     820 </span>            :          */
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :         for(; p &lt; pend; p++) {</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :                 int ch = *(const unsigned char *)p;</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :                 switch(ch) {</span>
<span class="lineNum">     824 </span>            :                 case 0x09: case 0x0a: case 0x0c: case 0x0d:
<span class="lineNum">     825 </span>            :                 case 0x20:
<span class="lineNum">     826 </span>            :                         /* Ignore whitespace */
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">     828 </span>            :                 case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: /*01234*/
<span class="lineNum">     829 </span>            :                 case 0x35: case 0x36: case 0x37: case 0x38: case 0x39: /*56789*/
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :                         clv = (clv &lt;&lt; 4) + (ch - 0x30);</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     832 </span>            :                 case 0x41: case 0x42: case 0x43:        /* ABC */
<span class="lineNum">     833 </span>            :                 case 0x44: case 0x45: case 0x46:        /* DEF */
<span class="lineNum">     834 </span><span class="lineNoCov">          0 :                         clv = (clv &lt;&lt; 4) + (ch - 0x41 + 10);</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     836 </span>            :                 case 0x61: case 0x62: case 0x63:        /* abc */
<span class="lineNum">     837 </span>            :                 case 0x64: case 0x65: case 0x66:        /* def */
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :                         clv = (clv &lt;&lt; 4) + (ch - 0x61 + 10);</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     840 </span>            :                 default:
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :                         *buf = 0;       /* JIC */</span>
<span class="lineNum">     842 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     843 </span>            :                 }
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :                 if(half++) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :                         half = 0;</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :                         *buf++ = clv;</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :                         chunk_stop = p + 1;</span>
<span class="lineNum">     848 </span>            :                 }
<span class="lineNum">     849 </span>            :         }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :         /*
<span class="lineNum">     852 </span>            :          * Check partial decoding.
<span class="lineNum">     853 </span>            :          */
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :         if(half) {</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :                 if(have_more) {</span>
<span class="lineNum">     856 </span>            :                         /*
<span class="lineNum">     857 </span>            :                          * Partial specification is fine,
<span class="lineNum">     858 </span>            :                          * because no more more PXER_TEXT data is available.
<span class="lineNum">     859 </span>            :                          */
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :                         *buf++ = clv &lt;&lt; 4;</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :                         chunk_stop = p;</span>
<span class="lineNum">     862 </span>            :                 }
<span class="lineNum">     863 </span>            :         } else {
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :                 chunk_stop = p;</span>
<span class="lineNum">     865 </span>            :         }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :         st-&gt;size = buf - st-&gt;buf; /* Adjust the buffer size */</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :         assert(st-&gt;size &lt;= new_size);</span>
<span class="lineNum">     869 </span><span class="lineNoCov">          0 :         st-&gt;buf[st-&gt;size] = 0;            /* Courtesy termination */</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineNoCov">          0 :         return (chunk_stop - (const char *)chunk_buf);  /* Converted size */</span>
<span class="lineNum">     872 </span>            : }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /*
<a name="875"><span class="lineNum">     875 </span>            :  * Convert from binary format: &quot;00101011101&quot;</a>
<span class="lineNum">     876 </span>            :  */
<span class="lineNum">     877 </span><span class="lineNoCov">          0 : static ssize_t OCTET_STRING__convert_binary(void *sptr, const void *chunk_buf, size_t chunk_size, int have_more) {</span>
<span class="lineNum">     878 </span><span class="lineNoCov">          0 :         BIT_STRING_t *st = (BIT_STRING_t *)sptr;</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         const char *p = (const char *)chunk_buf;</span>
<span class="lineNum">     880 </span><span class="lineNoCov">          0 :         const char *pend = p + chunk_size;</span>
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :         int bits_unused = st-&gt;bits_unused &amp; 0x7;</span>
<span class="lineNum">     882 </span>            :         uint8_t *buf;
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            :         /* Reallocate buffer according to high cap estimation */
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :         size_t new_size = st-&gt;size + (chunk_size + 7) / 8;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :         void *nptr = REALLOC(st-&gt;buf, new_size + 1);</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         if(!nptr) return -1;</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :         st-&gt;buf = (uint8_t *)nptr;</span>
<span class="lineNum">     889 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf + st-&gt;size;</span>
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            :         (void)have_more;
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :         if(bits_unused == 0)</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :                 bits_unused = 8;</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         else if(st-&gt;size)</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :                 buf--;</span>
<span class="lineNum">     897 </span>            : 
<span class="lineNum">     898 </span>            :         /*
<span class="lineNum">     899 </span>            :          * Convert series of 0 and 1 into the octet string.
<span class="lineNum">     900 </span>            :          */
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         for(; p &lt; pend; p++) {</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :                 int ch = *(const unsigned char *)p;</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :                 switch(ch) {</span>
<span class="lineNum">     904 </span>            :                 case 0x09: case 0x0a: case 0x0c: case 0x0d:
<span class="lineNum">     905 </span>            :                 case 0x20:
<span class="lineNum">     906 </span>            :                         /* Ignore whitespace */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     908 </span>            :                 case 0x30:
<span class="lineNum">     909 </span>            :                 case 0x31:
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :                         if(bits_unused-- &lt;= 0) {</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                                 *++buf = 0;     /* Clean the cell */</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :                                 bits_unused = 7;</span>
<span class="lineNum">     913 </span>            :                         }
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                         *buf |= (ch&amp;1) &lt;&lt; bits_unused;</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     916 </span>            :                 default:
<span class="lineNum">     917 </span><span class="lineNoCov">          0 :                         st-&gt;bits_unused = bits_unused;</span>
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     919 </span>            :                 }
<span class="lineNum">     920 </span>            :         }
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :         if(bits_unused == 8) {</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :                 st-&gt;size = buf - st-&gt;buf;</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :                 st-&gt;bits_unused = 0;</span>
<span class="lineNum">     925 </span>            :         } else {
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :                 st-&gt;size = buf - st-&gt;buf + 1;</span>
<span class="lineNum">     927 </span><span class="lineNoCov">          0 :                 st-&gt;bits_unused = bits_unused;</span>
<span class="lineNum">     928 </span>            :         }
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :         assert(st-&gt;size &lt;= new_size);</span>
<span class="lineNum">     931 </span><span class="lineNoCov">          0 :         st-&gt;buf[st-&gt;size] = 0;            /* Courtesy termination */</span>
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :         return chunk_size;      /* Converted in full */</span>
<span class="lineNum">     934 </span>            : }
<span class="lineNum">     935 </span>            : 
<span class="lineNum">     936 </span>            : /*
<span class="lineNum">     937 </span>            :  * Something like strtod(), but with stricter rules.
<a name="938"><span class="lineNum">     938 </span>            :  */</a>
<span class="lineNum">     939 </span>            : static int
<span class="lineNum">     940 </span><span class="lineNoCov">          0 : OS__strtoent(int base, const char *buf, const char *end, int32_t *ret_value) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :         const int32_t last_unicode_codepoint = 0x10ffff;</span>
<span class="lineNum">     942 </span><span class="lineNoCov">          0 :         int32_t val = 0;</span>
<span class="lineNum">     943 </span>            :         const char *p;
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :         for(p = buf; p &lt; end; p++) {</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :                 int ch = *p;</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :                 switch(ch) {</span>
<span class="lineNum">     949 </span>            :                 case 0x30: case 0x31: case 0x32: case 0x33: case 0x34: /*01234*/
<span class="lineNum">     950 </span>            :                 case 0x35: case 0x36: case 0x37: case 0x38: case 0x39: /*56789*/
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :                         val = val * base + (ch - 0x30);</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     953 </span>            :                 case 0x41: case 0x42: case 0x43:        /* ABC */
<span class="lineNum">     954 </span>            :                 case 0x44: case 0x45: case 0x46:        /* DEF */
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :                         val = val * base + (ch - 0x41 + 10);</span>
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     957 </span>            :                 case 0x61: case 0x62: case 0x63:        /* abc */
<span class="lineNum">     958 </span>            :                 case 0x64: case 0x65: case 0x66:        /* def */
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                         val = val * base + (ch - 0x61 + 10);</span>
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     961 </span>            :                 case 0x3b:      /* ';' */
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :                         *ret_value = val;</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                         return (p - buf) + 1;</span>
<span class="lineNum">     964 </span>            :                 default:
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                         return -1;      /* Character set error */</span>
<span class="lineNum">     966 </span>            :                 }
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span>            :                 /* Value exceeds the Unicode range. */
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :                 if(val &gt; last_unicode_codepoint) {</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">     971 </span>            :                 }
<span class="lineNum">     972 </span>            :         }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :         *ret_value = -1;</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :         return (p - buf);</span>
<span class="lineNum">     976 </span>            : }
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            : /*
<span class="lineNum">     979 </span>            :  * Convert from the plain UTF-8 format, expanding entity references: &quot;2 &amp;lt; 3&quot;
<a name="980"><span class="lineNum">     980 </span>            :  */</a>
<span class="lineNum">     981 </span>            : static ssize_t
<span class="lineNum">     982 </span><span class="lineNoCov">          0 : OCTET_STRING__convert_entrefs(void *sptr, const void *chunk_buf,</span>
<span class="lineNum">     983 </span>            :                               size_t chunk_size, int have_more) {
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :     OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :         const char *p = (const char *)chunk_buf;</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :         const char *pend = p + chunk_size;</span>
<span class="lineNum">     987 </span>            :         uint8_t *buf;
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :         /* Reallocate buffer */
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :         size_t new_size = st-&gt;size + chunk_size;</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :         void *nptr = REALLOC(st-&gt;buf, new_size + 1);</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :         if(!nptr) return -1;</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :         st-&gt;buf = (uint8_t *)nptr;</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf + st-&gt;size;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :         /*
<span class="lineNum">     997 </span>            :          * Convert series of 0 and 1 into the octet string.
<span class="lineNum">     998 </span>            :          */
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :         for(; p &lt; pend; p++) {</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :                 int ch = *(const unsigned char *)p;</span>
<span class="lineNum">    1001 </span>            :                 int len;        /* Length of the rest of the chunk */
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :                 if(ch != 0x26 /* '&amp;' */) {</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :                         *buf++ = ch;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :                         continue;       /* That was easy... */</span>
<span class="lineNum">    1006 </span>            :                 }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span>            :                 /*
<span class="lineNum">    1009 </span>            :                  * Process entity reference.
<span class="lineNum">    1010 </span>            :                  */
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :                 len = chunk_size - (p - (const char *)chunk_buf);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :                 if(len == 1 /* &quot;&amp;&quot; */) goto want_more;</span>
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :                 if(p[1] == 0x23 /* '#' */) {</span>
<span class="lineNum">    1014 </span>            :                         const char *pval;       /* Pointer to start of digits */
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                         int32_t val = 0;        /* Entity reference value */</span>
<span class="lineNum">    1016 </span>            :                         int base;
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                         if(len == 2 /* &quot;&amp;#&quot; */) goto want_more;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                         if(p[2] == 0x78 /* 'x' */)</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                                 pval = p + 3, base = 16;</span>
<span class="lineNum">    1021 </span>            :                         else
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                                 pval = p + 2, base = 10;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :                         len = OS__strtoent(base, pval, p + len, &amp;val);</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :                         if(len == -1) {</span>
<span class="lineNum">    1025 </span>            :                                 /* Invalid charset. Just copy verbatim. */
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :                                 *buf++ = ch;</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1028 </span>            :                         }
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :                         if(!len || pval[len-1] != 0x3b) goto want_more;</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :                         assert(val &gt; 0);</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                         p += (pval - p) + len - 1; /* Advance past entref */</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :                         if(val &lt; 0x80) {</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :                                 *buf++ = (char)val;</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :                         } else if(val &lt; 0x800) {</span>
<span class="lineNum">    1036 </span><span class="lineNoCov">          0 :                                 *buf++ = 0xc0 | ((val &gt;&gt; 6));</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &amp; 0x3f));</span>
<span class="lineNum">    1038 </span><span class="lineNoCov">          0 :                         } else if(val &lt; 0x10000) {</span>
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 :                                 *buf++ = 0xe0 | ((val &gt;&gt; 12));</span>
<span class="lineNum">    1040 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 6) &amp; 0x3f);</span>
<span class="lineNum">    1041 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &amp; 0x3f));</span>
<span class="lineNum">    1042 </span><span class="lineNoCov">          0 :                         } else if(val &lt; 0x200000) {</span>
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :                                 *buf++ = 0xf0 | ((val &gt;&gt; 18));</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 12) &amp; 0x3f);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 6) &amp; 0x3f);</span>
<span class="lineNum">    1046 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &amp; 0x3f));</span>
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :                         } else if(val &lt; 0x4000000) {</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :                                 *buf++ = 0xf8 | ((val &gt;&gt; 24));</span>
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 18) &amp; 0x3f);</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 12) &amp; 0x3f);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 6) &amp; 0x3f);</span>
<span class="lineNum">    1052 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &amp; 0x3f));</span>
<span class="lineNum">    1053 </span>            :                         } else {
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :                                 *buf++ = 0xfc | ((val &gt;&gt; 30) &amp; 0x1);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 24) &amp; 0x3f);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 18) &amp; 0x3f);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 12) &amp; 0x3f);</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &gt;&gt; 6) &amp; 0x3f);</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x80 | ((val &amp; 0x3f));</span>
<span class="lineNum">    1060 </span>            :                         }
<span class="lineNum">    1061 </span>            :                 } else {
<span class="lineNum">    1062 </span>            :                         /*
<span class="lineNum">    1063 </span>            :                          * Ugly, limited parsing of &amp;amp; &amp;gt; &amp;lt;
<span class="lineNum">    1064 </span>            :                          */
<span class="lineNum">    1065 </span><span class="lineNoCov">          0 :                         char *sc = (char *)memchr(p, 0x3b, len &gt; 5 ? 5 : len);</span>
<span class="lineNum">    1066 </span><span class="lineNoCov">          0 :                         if(!sc) goto want_more;</span>
<span class="lineNum">    1067 </span><span class="lineNoCov">          0 :                         if((sc - p) == 4</span>
<span class="lineNum">    1068 </span><span class="lineNoCov">          0 :                                 &amp;&amp; p[1] == 0x61 /* 'a' */</span>
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 :                                 &amp;&amp; p[2] == 0x6d /* 'm' */</span>
<span class="lineNum">    1070 </span><span class="lineNoCov">          0 :                                 &amp;&amp; p[3] == 0x70 /* 'p' */) {</span>
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :                                 *buf++ = 0x26;</span>
<span class="lineNum">    1072 </span><span class="lineNoCov">          0 :                                 p = sc;</span>
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1074 </span>            :                         }
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :                         if((sc - p) == 3) {</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 :                                 if(p[1] == 0x6c) {</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :                                         *buf = 0x3c;    /* '&lt;' */</span>
<span class="lineNum">    1078 </span><span class="lineNoCov">          0 :                                 } else if(p[1] == 0x67) {</span>
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :                                         *buf = 0x3e;    /* '&gt;' */</span>
<span class="lineNum">    1080 </span>            :                                 } else {
<span class="lineNum">    1081 </span>            :                                         /* Unsupported entity reference */
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :                                         *buf++ = ch;</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    1084 </span>            :                                 }
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :                                 if(p[2] != 0x74) {</span>
<span class="lineNum">    1086 </span>            :                                         /* Unsupported entity reference */
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :                                         *buf++ = ch;</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    1089 </span>            :                                 }
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :                                 buf++;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :                                 p = sc;</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :                                 continue;</span>
<span class="lineNum">    1093 </span>            :                         }
<span class="lineNum">    1094 </span>            :                         /* Unsupported entity reference */
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :                         *buf++ = ch;</span>
<span class="lineNum">    1096 </span>            :                 }
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">    1099 </span>            :         want_more:
<span class="lineNum">    1100 </span><span class="lineNoCov">          0 :                 if(have_more) {</span>
<span class="lineNum">    1101 </span>            :                         /*
<span class="lineNum">    1102 </span>            :                          * We know that no more data (of the same type)
<span class="lineNum">    1103 </span>            :                          * is coming. Copy the rest verbatim.
<span class="lineNum">    1104 </span>            :                          */
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :                         *buf++ = ch;</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1107 </span>            :                 }
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :                 chunk_size = (p - (const char *)chunk_buf);</span>
<span class="lineNum">    1109 </span>            :                 /* Processing stalled: need more data */
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1111 </span>            :         }
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :         st-&gt;size = buf - st-&gt;buf;</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :         assert(st-&gt;size &lt;= new_size);</span>
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :         st-&gt;buf[st-&gt;size] = 0;            /* Courtesy termination */</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineNoCov">          0 :         return chunk_size;      /* Converted in full */</span>
<span class="lineNum">    1118 </span>            : }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /*
<span class="lineNum">    1121 </span>            :  * Decode OCTET STRING from the XML element's body.
<a name="1122"><span class="lineNum">    1122 </span>            :  */</a>
<span class="lineNum">    1123 </span>            : static asn_dec_rval_t
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : OCTET_STRING__decode_xer(</span>
<span class="lineNum">    1125 </span>            :     const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *td,
<span class="lineNum">    1126 </span>            :     void **sptr, const char *opt_mname, const void *buf_ptr, size_t size,
<span class="lineNum">    1127 </span>            :     int (*opt_unexpected_tag_decoder)(void *struct_ptr, const void *chunk_buf,
<span class="lineNum">    1128 </span>            :                                       size_t chunk_size),
<span class="lineNum">    1129 </span>            :     ssize_t (*body_receiver)(void *struct_ptr, const void *chunk_buf,
<span class="lineNum">    1130 </span>            :                              size_t chunk_size, int have_more)) {
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :     OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;</span>
<span class="lineNum">    1132 </span><span class="lineNoCov">          0 :         const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    1133 </span>            :                                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :                                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :         const char *xml_tag = opt_mname ? opt_mname : td-&gt;xml_tag;</span>
<span class="lineNum">    1136 </span>            :         asn_struct_ctx_t *ctx;          /* Per-structure parser context */
<span class="lineNum">    1137 </span>            :         asn_dec_rval_t rval;            /* Return value from the decoder */
<span class="lineNum">    1138 </span>            :         int st_allocated;
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            :         /*
<span class="lineNum">    1141 </span>            :          * Create the string if does not exist.
<span class="lineNum">    1142 </span>            :          */
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :         if(!st) {</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 st = (OCTET_STRING_t *)CALLOC(1, specs-&gt;struct_size);</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :                 *sptr = (void *)st;</span>
<span class="lineNum">    1146 </span><span class="lineNoCov">          0 :                 if(!st) goto sta_failed;</span>
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :                 st_allocated = 1;</span>
<span class="lineNum">    1148 </span>            :         } else {
<span class="lineNum">    1149 </span><span class="lineNoCov">          0 :                 st_allocated = 0;</span>
<span class="lineNum">    1150 </span>            :         }
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :         if(!st-&gt;buf) {</span>
<span class="lineNum">    1152 </span>            :                 /* This is separate from above section */
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :                 st-&gt;buf = (uint8_t *)CALLOC(1, 1);</span>
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :                 if(!st-&gt;buf) {</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :                         if(st_allocated) {</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :                                 *sptr = 0;</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :                                 goto stb_failed;</span>
<span class="lineNum">    1158 </span>            :                         } else {
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :                                 goto sta_failed;</span>
<span class="lineNum">    1160 </span>            :                         }
<span class="lineNum">    1161 </span>            :                 }
<span class="lineNum">    1162 </span>            :         }
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :         /* Restore parsing context */
<span class="lineNum">    1165 </span><span class="lineNoCov">          0 :         ctx = (asn_struct_ctx_t *)(((char *)*sptr) + specs-&gt;ctx_offset);</span>
<span class="lineNum">    1166 </span>            : 
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :         return xer_decode_general(opt_codec_ctx, ctx, *sptr, xml_tag,</span>
<span class="lineNum">    1168 </span>            :                 buf_ptr, size, opt_unexpected_tag_decoder, body_receiver);
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            : stb_failed:
<span class="lineNum">    1171 </span><span class="lineNoCov">          0 :         FREEMEM(st);</span>
<span class="lineNum">    1172 </span>            : sta_failed:
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :         rval.code = RC_FAIL;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :         rval.consumed = 0;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :         return rval;</span>
<span class="lineNum">    1176 </span>            : }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span>            : /*
<span class="lineNum">    1179 </span>            :  * Decode OCTET STRING from the hexadecimal data.
<a name="1180"><span class="lineNum">    1180 </span>            :  */</a>
<span class="lineNum">    1181 </span>            : asn_dec_rval_t
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 : OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">    1183 </span>            :                             const asn_TYPE_descriptor_t *td, void **sptr,
<span class="lineNum">    1184 </span>            :                             const char *opt_mname, const void *buf_ptr,
<span class="lineNum">    1185 </span>            :                             size_t size) {
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 :     return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,</span>
<span class="lineNum">    1187 </span>            :                 buf_ptr, size, 0, OCTET_STRING__convert_hexadecimal);
<span class="lineNum">    1188 </span>            : }
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span>            : /*
<span class="lineNum">    1191 </span>            :  * Decode OCTET STRING from the binary (0/1) data.
<a name="1192"><span class="lineNum">    1192 </span>            :  */</a>
<span class="lineNum">    1193 </span>            : asn_dec_rval_t
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 : OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">    1195 </span>            :                                const asn_TYPE_descriptor_t *td, void **sptr,
<span class="lineNum">    1196 </span>            :                                const char *opt_mname, const void *buf_ptr,
<span class="lineNum">    1197 </span>            :                                size_t size) {
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :     return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,</span>
<span class="lineNum">    1199 </span>            :                 buf_ptr, size, 0, OCTET_STRING__convert_binary);
<span class="lineNum">    1200 </span>            : }
<span class="lineNum">    1201 </span>            : 
<span class="lineNum">    1202 </span>            : /*
<span class="lineNum">    1203 </span>            :  * Decode OCTET STRING from the string (ASCII/UTF-8) data.
<a name="1204"><span class="lineNum">    1204 </span>            :  */</a>
<span class="lineNum">    1205 </span>            : asn_dec_rval_t
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 : OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">    1207 </span>            :                              const asn_TYPE_descriptor_t *td, void **sptr,
<span class="lineNum">    1208 </span>            :                              const char *opt_mname, const void *buf_ptr,
<span class="lineNum">    1209 </span>            :                              size_t size) {
<span class="lineNum">    1210 </span><span class="lineNoCov">          0 :     return OCTET_STRING__decode_xer(opt_codec_ctx, td, sptr, opt_mname,</span>
<span class="lineNum">    1211 </span>            :                 buf_ptr, size,
<span class="lineNum">    1212 </span>            :                 OCTET_STRING__handle_control_chars,
<span class="lineNum">    1213 </span>            :                 OCTET_STRING__convert_entrefs);
<span class="lineNum">    1214 </span>            : }
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            : #ifndef  ASN_DISABLE_PER_SUPPORT
<a name="1217"><span class="lineNum">    1217 </span>            : </a>
<span class="lineNum">    1218 </span>            : static int
<span class="lineNum">    1219 </span><span class="lineCov">         48 : OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf,</span>
<span class="lineNum">    1220 </span>            :                 size_t units, unsigned int bpc, unsigned int unit_bits,
<span class="lineNum">    1221 </span>            :                 long lb, long ub, const asn_per_constraints_t *pc) {
<span class="lineNum">    1222 </span><span class="lineCov">         48 :         uint8_t *end = buf + units * bpc;</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            :         ASN_DEBUG(&quot;Expanding %d characters into (%ld..%ld):%d&quot;,
<span class="lineNum">    1225 </span>            :                 (int)units, lb, ub, unit_bits);
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            :         /* X.691: 27.5.4 */
<span class="lineNum">    1228 </span><span class="lineCov">         48 :         if((unsigned long)ub &lt;= ((unsigned long)2 &lt;&lt; (unit_bits - 1))) {</span>
<span class="lineNum">    1229 </span>            :                 /* Decode without translation */
<span class="lineNum">    1230 </span><span class="lineCov">         48 :                 lb = 0;</span>
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :         } else if(pc &amp;&amp; pc-&gt;code2value) {</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :                 if(unit_bits &gt; 16)</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :                         return 1;       /* FATAL: can't have constrained</span>
<span class="lineNum">    1234 </span>            :                                          * UniversalString with more than
<span class="lineNum">    1235 </span>            :                                          * 16 million code points */
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :                 for(; buf &lt; end; buf += bpc) {</span>
<span class="lineNum">    1237 </span>            :                         int value;
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :                         int code = per_get_few_bits(po, unit_bits);</span>
<span class="lineNum">    1239 </span><span class="lineNoCov">          0 :                         if(code &lt; 0) return -1;      /* WMORE */</span>
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :                         value = pc-&gt;code2value(code);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :                         if(value &lt; 0) {</span>
<span class="lineNum">    1242 </span>            :                                 ASN_DEBUG(&quot;Code %d (0x%02x) is&quot;
<span class="lineNum">    1243 </span>            :                                         &quot; not in map (%ld..%ld)&quot;,
<span class="lineNum">    1244 </span>            :                                         code, code, lb, ub);
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :                                 return 1;       /* FATAL */</span>
<span class="lineNum">    1246 </span>            :                         }
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :                         switch(bpc) {</span>
<span class="lineNum">    1248 </span><span class="lineNoCov">          0 :                         case 1: *buf = value; break;</span>
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :                         case 2: buf[0] = value &gt;&gt; 8; buf[1] = value; break;</span>
<span class="lineNum">    1250 </span><span class="lineNoCov">          0 :                         case 4: buf[0] = value &gt;&gt; 24; buf[1] = value &gt;&gt; 16;</span>
<span class="lineNum">    1251 </span><span class="lineNoCov">          0 :                                 buf[2] = value &gt;&gt; 8; buf[3] = value; break;</span>
<span class="lineNum">    1252 </span>            :                         }
<span class="lineNum">    1253 </span>            :                 }
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    1255 </span>            :         }
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span>            :         /* Shortcut the no-op copying to the aligned structure */
<span class="lineNum">    1258 </span><span class="lineCov">         48 :         if(lb == 0 &amp;&amp; (unit_bits == 8 * bpc)) {</span>
<span class="lineNum">    1259 </span><span class="lineCov">         48 :                 return per_get_many_bits(po, buf, 0, unit_bits * units);</span>
<span class="lineNum">    1260 </span>            :         }
<span class="lineNum">    1261 </span>            : 
<span class="lineNum">    1262 </span><span class="lineNoCov">          0 :         for(; buf &lt; end; buf += bpc) {</span>
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :                 int32_t code = per_get_few_bits(po, unit_bits);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :                 int32_t ch = code + lb;</span>
<span class="lineNum">    1265 </span><span class="lineNoCov">          0 :                 if(code &lt; 0) return -1;      /* WMORE */</span>
<span class="lineNum">    1266 </span><span class="lineNoCov">          0 :                 if(ch &gt; ub) {</span>
<span class="lineNum">    1267 </span>            :                         ASN_DEBUG(&quot;Code %d is out of range (%ld..%ld)&quot;,
<span class="lineNum">    1268 </span>            :                                 ch, lb, ub);
<span class="lineNum">    1269 </span><span class="lineNoCov">          0 :                         return 1;       /* FATAL */</span>
<span class="lineNum">    1270 </span>            :                 }
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 :                 switch(bpc) {</span>
<span class="lineNum">    1272 </span><span class="lineNoCov">          0 :                 case 1: *buf = ch; break;</span>
<span class="lineNum">    1273 </span><span class="lineNoCov">          0 :                 case 2: buf[0] = ch &gt;&gt; 8; buf[1] = ch; break;</span>
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :                 case 4: buf[0] = ch &gt;&gt; 24; buf[1] = ch &gt;&gt; 16;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :                         buf[2] = ch &gt;&gt; 8; buf[3] = ch; break;</span>
<span class="lineNum">    1276 </span>            :                 }
<span class="lineNum">    1277 </span>            :         }
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    1280 </span>            : }
<a name="1281"><span class="lineNum">    1281 </span>            : </a>
<span class="lineNum">    1282 </span>            : static int
<span class="lineNum">    1283 </span><span class="lineCov">         26 : OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf,</span>
<span class="lineNum">    1284 </span>            :                 size_t units, unsigned int bpc, unsigned int unit_bits,
<span class="lineNum">    1285 </span>            :                 long lb, long ub, const asn_per_constraints_t *pc) {
<span class="lineNum">    1286 </span><span class="lineCov">         26 :         const uint8_t *end = buf + units * bpc;</span>
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :         ASN_DEBUG(&quot;Squeezing %d characters into (%ld..%ld):%d (%d bpc)&quot;,
<span class="lineNum">    1289 </span>            :                 (int)units, lb, ub, unit_bits, bpc);
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            :         /* X.691: 27.5.4 */
<span class="lineNum">    1292 </span><span class="lineCov">         26 :         if((unsigned long)ub &lt;= ((unsigned long)2 &lt;&lt; (unit_bits - 1))) {</span>
<span class="lineNum">    1293 </span>            :                 /* Encode as is */
<span class="lineNum">    1294 </span><span class="lineCov">         26 :                 lb = 0;</span>
<span class="lineNum">    1295 </span><span class="lineNoCov">          0 :         } else if(pc &amp;&amp; pc-&gt;value2code) {</span>
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :                 for(; buf &lt; end; buf += bpc) {</span>
<span class="lineNum">    1297 </span>            :                         int code;
<span class="lineNum">    1298 </span>            :                         uint32_t value;
<span class="lineNum">    1299 </span><span class="lineNoCov">          0 :                         switch(bpc) {</span>
<span class="lineNum">    1300 </span><span class="lineNoCov">          0 :                         case 1: value = *(const uint8_t *)buf; break;</span>
<span class="lineNum">    1301 </span><span class="lineNoCov">          0 :                         case 2: value = (buf[0] &lt;&lt; 8) | buf[1]; break;</span>
<span class="lineNum">    1302 </span><span class="lineNoCov">          0 :                         case 4: value = (buf[0] &lt;&lt; 24) | (buf[1] &lt;&lt; 16)</span>
<span class="lineNum">    1303 </span><span class="lineNoCov">          0 :                                         | (buf[2] &lt;&lt; 8) | buf[3]; break;</span>
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 :                         default: return -1;</span>
<span class="lineNum">    1305 </span>            :                         }
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :                         code = pc-&gt;value2code(value);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :                         if(code &lt; 0) {</span>
<span class="lineNum">    1308 </span>            :                                 ASN_DEBUG(&quot;Character %d (0x%02x) is&quot;
<span class="lineNum">    1309 </span>            :                                         &quot; not in map (%ld..%ld)&quot;,
<span class="lineNum">    1310 </span>            :                                         *buf, *buf, lb, ub);
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    1312 </span>            :                         }
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :                         if(per_put_few_bits(po, code, unit_bits))</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    1315 </span>            :                 }
<span class="lineNum">    1316 </span>            :         }
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span>            :         /* Shortcut the no-op copying to the aligned structure */
<span class="lineNum">    1319 </span><span class="lineCov">         26 :         if(lb == 0 &amp;&amp; (unit_bits == 8 * bpc)) {</span>
<span class="lineNum">    1320 </span><span class="lineCov">         26 :                 return per_put_many_bits(po, buf, unit_bits * units);</span>
<span class="lineNum">    1321 </span>            :         }
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :     for(ub -= lb; buf &lt; end; buf += bpc) {</span>
<span class="lineNum">    1324 </span>            :         int ch;
<span class="lineNum">    1325 </span>            :         uint32_t value;
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         switch(bpc) {</span>
<span class="lineNum">    1327 </span>            :         case 1:
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :             value = *(const uint8_t *)buf;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1330 </span>            :         case 2:
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :             value = (buf[0] &lt;&lt; 8) | buf[1];</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1333 </span>            :         case 4:
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :             value = (buf[0] &lt;&lt; 24) | (buf[1] &lt;&lt; 16) | (buf[2] &lt;&lt; 8) | buf[3];</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    1336 </span>            :         default:
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">    1338 </span>            :         }
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :         ch = value - lb;</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :         if(ch &lt; 0 || ch &gt; ub) {</span>
<span class="lineNum">    1341 </span>            :             ASN_DEBUG(&quot;Character %d (0x%02x) is out of range (%ld..%ld)&quot;, *buf,
<span class="lineNum">    1342 </span>            :                       value, lb, ub + lb);
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 :             return -1;</span>
<span class="lineNum">    1344 </span>            :         }
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :         if(per_put_few_bits(po, ch, unit_bits)) return -1;</span>
<span class="lineNum">    1346 </span>            :     }
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1349 </span>            : }
<span class="lineNum">    1350 </span>            : 
<span class="lineNum">    1351 </span>            : static asn_per_constraints_t asn_DEF_OCTET_STRING_constraints = {
<span class="lineNum">    1352 </span>            :         { APC_CONSTRAINED, 8, 8, 0, 255 },
<span class="lineNum">    1353 </span>            :         { APC_SEMI_CONSTRAINED, -1, -1, 0, 0 },
<span class="lineNum">    1354 </span>            :         0, 0
<span class="lineNum">    1355 </span>            : };
<a name="1356"><span class="lineNum">    1356 </span>            : </a>
<span class="lineNum">    1357 </span>            : asn_dec_rval_t
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 : OCTET_STRING_decode_uper(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">    1359 </span>            :                          const asn_TYPE_descriptor_t *td,
<span class="lineNum">    1360 </span>            :                          const asn_per_constraints_t *constraints, void **sptr,
<span class="lineNum">    1361 </span>            :                          asn_per_data_t *pd) {
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :     const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    1363 </span>            :                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    1364 </span><span class="lineNoCov">          0 :                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    1365 </span><span class="lineNoCov">          0 :     const asn_per_constraints_t *pc =</span>
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :         constraints ? constraints : td-&gt;encoding_constraints.per_constraints;</span>
<span class="lineNum">    1367 </span>            :     const asn_per_constraint_t *cval;
<span class="lineNum">    1368 </span>            :         const asn_per_constraint_t *csiz;
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         asn_dec_rval_t rval = { RC_OK, 0 };</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         OCTET_STRING_t *st = (OCTET_STRING_t *)*sptr;</span>
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :         ssize_t consumed_myself = 0;</span>
<span class="lineNum">    1372 </span>            :         int repeat;
<span class="lineNum">    1373 </span>            :         enum {
<span class="lineNum">    1374 </span>            :                 OS__BPC_CHAR    = 1,
<span class="lineNum">    1375 </span>            :                 OS__BPC_U16     = 2,
<span class="lineNum">    1376 </span>            :                 OS__BPC_U32     = 4
<span class="lineNum">    1377 </span>            :         } bpc;  /* Bytes per character */
<span class="lineNum">    1378 </span>            :         unsigned int unit_bits;
<span class="lineNum">    1379 </span>            :         unsigned int canonical_unit_bits;
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span>            :         (void)opt_codec_ctx;
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 :         if(pc) {</span>
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :                 cval = &amp;pc-&gt;value;</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :                 csiz = &amp;pc-&gt;size;</span>
<span class="lineNum">    1386 </span>            :         } else {
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :                 cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1389 </span>            :         }
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :         switch(specs-&gt;subvariant) {</span>
<span class="lineNum">    1392 </span>            :         default:
<span class="lineNum">    1393 </span>            :         case ASN_OSUBV_ANY:
<span class="lineNum">    1394 </span>            :         case ASN_OSUBV_BIT:
<span class="lineNum">    1395 </span>            :                 ASN_DEBUG(&quot;Unrecognized subvariant %d&quot;, specs-&gt;subvariant);
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :                 RETURN(RC_FAIL);</span>
<span class="lineNum">    1397 </span>            :                 break;
<span class="lineNum">    1398 </span>            :         case ASN_OSUBV_STR:
<span class="lineNum">    1399 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 8;</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_CHAR;</span>
<span class="lineNum">    1403 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1404 </span>            :         case ASN_OSUBV_U16:
<span class="lineNum">    1405 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 16;</span>
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U16;</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1410 </span>            :         case ASN_OSUBV_U32:
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 32;</span>
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U32;</span>
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1416 </span>            :         }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            :         /*
<span class="lineNum">    1419 </span>            :          * Allocate the string.
<span class="lineNum">    1420 </span>            :          */
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :         if(!st) {</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :                 st = (OCTET_STRING_t *)(*sptr = CALLOC(1, specs-&gt;struct_size));</span>
<span class="lineNum">    1423 </span><span class="lineNoCov">          0 :                 if(!st) RETURN(RC_FAIL);</span>
<span class="lineNum">    1424 </span>            :         }
<span class="lineNum">    1425 </span>            : 
<span class="lineNum">    1426 </span>            :         ASN_DEBUG(&quot;PER Decoding %s size %ld .. %ld bits %d&quot;,
<span class="lineNum">    1427 </span>            :                 csiz-&gt;flags &amp; APC_EXTENSIBLE ? &quot;extensible&quot; : &quot;non-extensible&quot;,
<span class="lineNum">    1428 </span>            :                 csiz-&gt;lower_bound, csiz-&gt;upper_bound, csiz-&gt;effective_bits);
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :         if(csiz-&gt;flags &amp; APC_EXTENSIBLE) {</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :                 int inext = per_get_few_bits(pd, 1);</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :                 if(inext &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :                 if(inext) {</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :                         csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :                         unit_bits = canonical_unit_bits;</span>
<span class="lineNum">    1436 </span>            :                 }
<span class="lineNum">    1437 </span>            :         }
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :         if(csiz-&gt;effective_bits &gt;= 0) {</span>
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :                 FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :                 if(bpc) {</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 :                         st-&gt;size = csiz-&gt;upper_bound * bpc;</span>
<span class="lineNum">    1443 </span>            :                 } else {
<span class="lineNum">    1444 </span><span class="lineNoCov">          0 :                         st-&gt;size = (csiz-&gt;upper_bound + 7) &gt;&gt; 3;</span>
<span class="lineNum">    1445 </span>            :                 }
<span class="lineNum">    1446 </span><span class="lineNoCov">          0 :                 st-&gt;buf = (uint8_t *)MALLOC(st-&gt;size + 1);</span>
<span class="lineNum">    1447 </span><span class="lineNoCov">          0 :                 if(!st-&gt;buf) { st-&gt;size = 0; RETURN(RC_FAIL); }</span>
<span class="lineNum">    1448 </span>            :         }
<span class="lineNum">    1449 </span>            : 
<span class="lineNum">    1450 </span>            :         /* X.691, #16.5: zero-length encoding */
<span class="lineNum">    1451 </span>            :         /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
<span class="lineNum">    1452 </span>            :         /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :         if(csiz-&gt;effective_bits == 0) {</span>
<span class="lineNum">    1454 </span>            :                 int ret;
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :                 if(bpc) {</span>
<span class="lineNum">    1456 </span>            :                         ASN_DEBUG(&quot;Encoding OCTET STRING size %ld&quot;,
<span class="lineNum">    1457 </span>            :                                 csiz-&gt;upper_bound);
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :                         ret = OCTET_STRING_per_get_characters(pd, st-&gt;buf,</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :                                 csiz-&gt;upper_bound, bpc, unit_bits,</span>
<span class="lineNum">    1460 </span>            :                                 cval-&gt;lower_bound, cval-&gt;upper_bound, pc);
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :                         if(ret &gt; 0) RETURN(RC_FAIL);</span>
<span class="lineNum">    1462 </span>            :                 } else {
<span class="lineNum">    1463 </span>            :                         ASN_DEBUG(&quot;Encoding BIT STRING size %ld&quot;,
<span class="lineNum">    1464 </span>            :                                 csiz-&gt;upper_bound);
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :                         ret = per_get_many_bits(pd, st-&gt;buf, 0,</span>
<span class="lineNum">    1466 </span>            :                                             unit_bits * csiz-&gt;upper_bound);
<span class="lineNum">    1467 </span>            :                 }
<span class="lineNum">    1468 </span><span class="lineNoCov">          0 :                 if(ret &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1469 </span><span class="lineNoCov">          0 :                 consumed_myself += unit_bits * csiz-&gt;upper_bound;</span>
<span class="lineNum">    1470 </span><span class="lineNoCov">          0 :                 st-&gt;buf[st-&gt;size] = 0;</span>
<span class="lineNum">    1471 </span><span class="lineNoCov">          0 :                 RETURN(RC_OK);</span>
<span class="lineNum">    1472 </span>            :         }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineNoCov">          0 :         st-&gt;size = 0;</span>
<span class="lineNum">    1475 </span>            :         do {
<span class="lineNum">    1476 </span>            :                 ssize_t raw_len;
<span class="lineNum">    1477 </span>            :                 ssize_t len_bytes;
<span class="lineNum">    1478 </span>            :                 void *p;
<span class="lineNum">    1479 </span>            :                 int ret;
<span class="lineNum">    1480 </span>            : 
<span class="lineNum">    1481 </span>            :                 /* Get the PER length */
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :                 raw_len = uper_get_length(pd, csiz-&gt;effective_bits, csiz-&gt;lower_bound,</span>
<span class="lineNum">    1483 </span>            :                                           &amp;repeat);
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :                 if(raw_len &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :                 if(raw_len == 0 &amp;&amp; st-&gt;buf) break;</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span>            :                 ASN_DEBUG(&quot;Got PER length eb %ld, len %ld, %s (%s)&quot;,
<span class="lineNum">    1488 </span>            :                         (long)csiz-&gt;effective_bits, (long)raw_len,
<span class="lineNum">    1489 </span>            :                         repeat ? &quot;repeat&quot; : &quot;once&quot;, td-&gt;name);
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :         len_bytes = raw_len * bpc;</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :                 p = REALLOC(st-&gt;buf, st-&gt;size + len_bytes + 1);</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :                 if(!p) RETURN(RC_FAIL);</span>
<span class="lineNum">    1493 </span><span class="lineNoCov">          0 :                 st-&gt;buf = (uint8_t *)p;</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :         ret = OCTET_STRING_per_get_characters(pd, &amp;st-&gt;buf[st-&gt;size], raw_len,</span>
<span class="lineNum">    1496 </span>            :                                               bpc, unit_bits, cval-&gt;lower_bound,
<span class="lineNum">    1497 </span>            :                                               cval-&gt;upper_bound, pc);
<span class="lineNum">    1498 </span><span class="lineNoCov">          0 :         if(ret &gt; 0) RETURN(RC_FAIL);</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :                 if(ret &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1500 </span><span class="lineNoCov">          0 :                 st-&gt;size += len_bytes;</span>
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :         } while(repeat);</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :         st-&gt;buf[st-&gt;size] = 0;    /* nul-terminate */</span>
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :         return rval;</span>
<span class="lineNum">    1505 </span>            : }
<a name="1506"><span class="lineNum">    1506 </span>            : </a>
<span class="lineNum">    1507 </span>            : asn_enc_rval_t
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 : OCTET_STRING_encode_uper(const asn_TYPE_descriptor_t *td,</span>
<span class="lineNum">    1509 </span>            :                          const asn_per_constraints_t *constraints,
<span class="lineNum">    1510 </span>            :                          const void *sptr, asn_per_outp_t *po) {
<span class="lineNum">    1511 </span><span class="lineNoCov">          0 :     const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    1512 </span>            :                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 :         const asn_per_constraints_t *pc = constraints ? constraints</span>
<span class="lineNum">    1515 </span><span class="lineNoCov">          0 :                                 : td-&gt;encoding_constraints.per_constraints;</span>
<span class="lineNum">    1516 </span>            :         const asn_per_constraint_t *cval;
<span class="lineNum">    1517 </span>            :         const asn_per_constraint_t *csiz;
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :         const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;</span>
<span class="lineNum">    1519 </span><span class="lineNoCov">          0 :         asn_enc_rval_t er = { 0, 0, 0 };</span>
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 :         int inext = 0;          /* Lies not within extension root */</span>
<span class="lineNum">    1521 </span>            :         unsigned int unit_bits;
<span class="lineNum">    1522 </span>            :         unsigned int canonical_unit_bits;
<span class="lineNum">    1523 </span>            :         size_t size_in_units;
<span class="lineNum">    1524 </span>            :         const uint8_t *buf;
<span class="lineNum">    1525 </span>            :         int ret;
<span class="lineNum">    1526 </span>            :         enum {
<span class="lineNum">    1527 </span>            :                 OS__BPC_CHAR    = 1,
<span class="lineNum">    1528 </span>            :                 OS__BPC_U16     = 2,
<span class="lineNum">    1529 </span>            :                 OS__BPC_U32     = 4
<span class="lineNum">    1530 </span>            :         } bpc;  /* Bytes per character */
<span class="lineNum">    1531 </span>            :         int ct_extensible;
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :         if(!st || (!st-&gt;buf &amp;&amp; st-&gt;size))</span>
<span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span><span class="lineNoCov">          0 :         if(pc) {</span>
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :                 cval = &amp;pc-&gt;value;</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :                 csiz = &amp;pc-&gt;size;</span>
<span class="lineNum">    1539 </span>            :         } else {
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :                 cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1542 </span>            :         }
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :         ct_extensible = csiz-&gt;flags &amp; APC_EXTENSIBLE;</span>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :         switch(specs-&gt;subvariant) {</span>
<span class="lineNum">    1546 </span>            :         default:
<span class="lineNum">    1547 </span>            :         case ASN_OSUBV_ANY:
<span class="lineNum">    1548 </span>            :         case ASN_OSUBV_BIT:
<span class="lineNum">    1549 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1550 </span>            :         case ASN_OSUBV_STR:
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 8;</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_CHAR;</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :                 size_in_units = st-&gt;size;</span>
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1557 </span>            :         case ASN_OSUBV_U16:
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 16;</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U16;</span>
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 size_in_units = st-&gt;size &gt;&gt; 1;</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :                 if(st-&gt;size &amp; 1) {</span>
<span class="lineNum">    1564 </span>            :                         ASN_DEBUG(&quot;%s string size is not modulo 2&quot;, td-&gt;name);
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :                         ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1566 </span>            :                 }
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1568 </span>            :         case ASN_OSUBV_U32:
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 32;</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U32;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :                 size_in_units = st-&gt;size &gt;&gt; 2;</span>
<span class="lineNum">    1574 </span><span class="lineNoCov">          0 :                 if(st-&gt;size &amp; 3) {</span>
<span class="lineNum">    1575 </span>            :                         ASN_DEBUG(&quot;%s string size is not modulo 4&quot;, td-&gt;name);
<span class="lineNum">    1576 </span><span class="lineNoCov">          0 :                         ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1577 </span>            :                 }
<span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1579 </span>            :         }
<span class="lineNum">    1580 </span>            : 
<span class="lineNum">    1581 </span>            :         ASN_DEBUG(&quot;Encoding %s into %&quot; ASN_PRI_SIZE &quot; units of %d bits&quot;
<span class="lineNum">    1582 </span>            :                 &quot; (%ld..%ld, effective %d)%s&quot;,
<span class="lineNum">    1583 </span>            :                 td-&gt;name, size_in_units, unit_bits,
<span class="lineNum">    1584 </span>            :                 csiz-&gt;lower_bound, csiz-&gt;upper_bound,
<span class="lineNum">    1585 </span>            :                 csiz-&gt;effective_bits, ct_extensible ? &quot; EXT&quot; : &quot;&quot;);
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span>            :         /* Figure out whether size lies within PER visible constraint */
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :     if(csiz-&gt;effective_bits &gt;= 0) {</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :         if((ssize_t)size_in_units &lt; csiz-&gt;lower_bound</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :            || (ssize_t)size_in_units &gt; csiz-&gt;upper_bound) {</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :             if(ct_extensible) {</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1594 </span><span class="lineNoCov">          0 :                 unit_bits = canonical_unit_bits;</span>
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :                 inext = 1;</span>
<span class="lineNum">    1596 </span>            :             } else {
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1598 </span>            :             }
<span class="lineNum">    1599 </span>            :         }
<span class="lineNum">    1600 </span>            :     } else {
<span class="lineNum">    1601 </span><span class="lineNoCov">          0 :         inext = 0;</span>
<span class="lineNum">    1602 </span>            :     }
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineNoCov">          0 :     if(ct_extensible) {</span>
<span class="lineNum">    1605 </span>            :                 /* Declare whether length is [not] within extension root */
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :                 if(per_put_few_bits(po, inext, 1))</span>
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :                         ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1608 </span>            :         }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :     if(csiz-&gt;effective_bits &gt;= 0 &amp;&amp; !inext) {</span>
<span class="lineNum">    1611 </span>            :         ASN_DEBUG(&quot;Encoding %&quot; ASN_PRI_SIZE &quot; bytes (%ld), length in %d bits&quot;, st-&gt;size,
<span class="lineNum">    1612 </span>            :                   size_in_units - csiz-&gt;lower_bound, csiz-&gt;effective_bits);
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 :         ret = per_put_few_bits(po, size_in_units - csiz-&gt;lower_bound,</span>
<span class="lineNum">    1614 </span>            :                                csiz-&gt;effective_bits);
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :         if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1616 </span><span class="lineNoCov">          0 :         ret = OCTET_STRING_per_put_characters(po, st-&gt;buf, size_in_units, bpc,</span>
<span class="lineNum">    1617 </span>            :                                               unit_bits, cval-&gt;lower_bound,
<span class="lineNum">    1618 </span>            :                                               cval-&gt;upper_bound, pc);
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :         if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1620 </span><span class="lineNoCov">          0 :         ASN__ENCODED_OK(er);</span>
<span class="lineNum">    1621 </span>            :     }
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            :     ASN_DEBUG(&quot;Encoding %&quot; ASN_PRI_SIZE &quot; bytes&quot;, st-&gt;size);
<span class="lineNum">    1624 </span>            : 
<span class="lineNum">    1625 </span><span class="lineNoCov">          0 :     buf = st-&gt;buf;</span>
<span class="lineNum">    1626 </span>            :     ASN_DEBUG(&quot;Encoding %&quot; ASN_PRI_SIZE &quot; in units&quot;, size_in_units);
<span class="lineNum">    1627 </span>            :     do {
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :         int need_eom = 0;</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :         ssize_t may_save = uper_put_length(po, size_in_units, &amp;need_eom);</span>
<span class="lineNum">    1630 </span><span class="lineNoCov">          0 :         if(may_save &lt; 0) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1631 </span>            : 
<span class="lineNum">    1632 </span>            :         ASN_DEBUG(&quot;Encoding %&quot; ASN_PRI_SSIZE &quot; of %&quot; ASN_PRI_SIZE &quot;%s&quot;, may_save, size_in_units,
<span class="lineNum">    1633 </span>            :                   need_eom ? &quot;,+EOM&quot; : &quot;&quot;);
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span><span class="lineNoCov">          0 :         ret = OCTET_STRING_per_put_characters(po, buf, may_save, bpc, unit_bits,</span>
<span class="lineNum">    1636 </span>            :                                               cval-&gt;lower_bound,
<span class="lineNum">    1637 </span>            :                                               cval-&gt;upper_bound, pc);
<span class="lineNum">    1638 </span><span class="lineNoCov">          0 :         if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 :         buf += may_save * bpc;</span>
<span class="lineNum">    1641 </span><span class="lineNoCov">          0 :         size_in_units -= may_save;</span>
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :         assert(!(may_save &amp; 0x07) || !size_in_units);</span>
<span class="lineNum">    1643 </span><span class="lineNoCov">          0 :         if(need_eom &amp;&amp; uper_put_length(po, 0, 0))</span>
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :             ASN__ENCODE_FAILED; /* End of Message length */</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :     } while(size_in_units);</span>
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     ASN__ENCODED_OK(er);</span>
<span class="lineNum">    1648 </span>            : }
<a name="1649"><span class="lineNum">    1649 </span>            : </a>
<span class="lineNum">    1650 </span>            : asn_dec_rval_t
<span class="lineNum">    1651 </span><span class="lineCov">         61 : OCTET_STRING_decode_aper(const asn_codec_ctx_t *opt_codec_ctx,</span>
<span class="lineNum">    1652 </span>            :                          const asn_TYPE_descriptor_t *td,
<span class="lineNum">    1653 </span>            :                          const asn_per_constraints_t *constraints,
<span class="lineNum">    1654 </span>            :                          void **sptr, asn_per_data_t *pd) {
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">        122 :         const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    1657 </span>            :                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    1658 </span><span class="lineCov">         61 :                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    1659 </span><span class="lineCov">         61 :         const asn_per_constraints_t *pc = constraints ? constraints</span>
<span class="lineNum">    1660 </span><span class="lineCov">         61 :                                 : td-&gt;encoding_constraints.per_constraints;</span>
<span class="lineNum">    1661 </span>            :         const asn_per_constraint_t *cval;
<span class="lineNum">    1662 </span>            :         const asn_per_constraint_t *csiz;
<span class="lineNum">    1663 </span><span class="lineCov">         61 :         asn_dec_rval_t rval = { RC_OK, 0 };</span>
<span class="lineNum">    1664 </span><span class="lineCov">         61 :         BIT_STRING_t *st = (BIT_STRING_t *)*sptr;</span>
<span class="lineNum">    1665 </span><span class="lineCov">         61 :         ssize_t consumed_myself = 0;</span>
<span class="lineNum">    1666 </span>            :         int repeat;
<span class="lineNum">    1667 </span>            :         enum {
<span class="lineNum">    1668 </span>            :                 OS__BPC_BIT     = 0,
<span class="lineNum">    1669 </span>            :                 OS__BPC_CHAR    = 1,
<span class="lineNum">    1670 </span>            :                 OS__BPC_U16     = 2,
<span class="lineNum">    1671 </span>            :                 OS__BPC_U32     = 4
<span class="lineNum">    1672 </span>            :         } bpc;  /* Bytes per character */
<span class="lineNum">    1673 </span>            :         unsigned int unit_bits;
<span class="lineNum">    1674 </span>            :         unsigned int canonical_unit_bits;
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            :         (void)opt_codec_ctx;
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span><span class="lineCov">         61 :         if(pc) {</span>
<span class="lineNum">    1679 </span><span class="lineCov">         49 :                 cval = &amp;pc-&gt;value;</span>
<span class="lineNum">    1680 </span><span class="lineCov">         49 :                 csiz = &amp;pc-&gt;size;</span>
<span class="lineNum">    1681 </span>            :         } else {
<span class="lineNum">    1682 </span><span class="lineCov">         12 :                 cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1683 </span><span class="lineCov">         12 :                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1684 </span>            :         }
<span class="lineNum">    1685 </span>            : 
<span class="lineNum">    1686 </span><span class="lineCov">         61 :         switch(specs-&gt;subvariant) {</span>
<span class="lineNum">    1687 </span>            :         default:
<span class="lineNum">    1688 </span>            : /*      case ASN_OSUBV_ANY:
<span class="lineNum">    1689 </span>            :                 ASN_DEBUG(&quot;Unrecognized subvariant %d&quot;, specs-&gt;subvariant);
<span class="lineNum">    1690 </span>            :                 RETURN(RC_FAIL);
<span class="lineNum">    1691 </span>            : */
<span class="lineNum">    1692 </span>            :         case ASN_OSUBV_BIT:
<span class="lineNum">    1693 </span><span class="lineCov">         13 :                 canonical_unit_bits = unit_bits = 1;</span>
<span class="lineNum">    1694 </span><span class="lineCov">         13 :                 bpc = OS__BPC_BIT;</span>
<span class="lineNum">    1695 </span><span class="lineCov">         13 :                 break;</span>
<span class="lineNum">    1696 </span>            :         case ASN_OSUBV_ANY:
<span class="lineNum">    1697 </span>            :         case ASN_OSUBV_STR:
<span class="lineNum">    1698 </span><span class="lineCov">         48 :                 canonical_unit_bits = unit_bits = 8;</span>
<span class="lineNum">    1699 </span>            : /*              if(cval-&gt;flags &amp; APC_CONSTRAINED)
<span class="lineNum">    1700 </span>            :                         unit_bits = cval-&gt;range_bits;
<span class="lineNum">    1701 </span>            : */
<span class="lineNum">    1702 </span><span class="lineCov">         48 :                 bpc = OS__BPC_CHAR;</span>
<span class="lineNum">    1703 </span><span class="lineCov">         48 :                 break;</span>
<span class="lineNum">    1704 </span>            :         case ASN_OSUBV_U16:
<span class="lineNum">    1705 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 16;</span>
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1707 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U16;</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1710 </span>            :         case ASN_OSUBV_U32:
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 32;</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U32;</span>
<span class="lineNum">    1715 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1716 </span>            :         }
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span>            :         /*
<span class="lineNum">    1719 </span>            :          * Allocate the string.
<span class="lineNum">    1720 </span>            :          */
<span class="lineNum">    1721 </span><span class="lineCov">         61 :         if(!st) {</span>
<span class="lineNum">    1722 </span><span class="lineCov">          1 :                 st = (BIT_STRING_t *)(*sptr = CALLOC(1, specs-&gt;struct_size));</span>
<span class="lineNum">    1723 </span><span class="lineCov">          1 :                 if(!st) RETURN(RC_FAIL);</span>
<span class="lineNum">    1724 </span>            :         }
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            :         ASN_DEBUG(&quot;PER Decoding %s size %ld .. %ld bits %d&quot;,
<span class="lineNum">    1727 </span>            :                 csiz-&gt;flags &amp; APC_EXTENSIBLE ? &quot;extensible&quot; : &quot;non-extensible&quot;,
<span class="lineNum">    1728 </span>            :                 csiz-&gt;lower_bound, csiz-&gt;upper_bound, csiz-&gt;effective_bits);
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span><span class="lineCov">         61 :         if(csiz-&gt;flags &amp; APC_EXTENSIBLE) {</span>
<span class="lineNum">    1731 </span><span class="lineCov">          3 :                 int inext = per_get_few_bits(pd, 1);</span>
<span class="lineNum">    1732 </span><span class="lineCov">          3 :                 if(inext &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1733 </span><span class="lineCov">          3 :                 if(inext) {</span>
<span class="lineNum">    1734 </span><span class="lineCov">          1 :                         csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1735 </span><span class="lineCov">          1 :                         cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1736 </span><span class="lineCov">          1 :                         unit_bits = canonical_unit_bits;</span>
<span class="lineNum">    1737 </span>            :                 }
<span class="lineNum">    1738 </span>            :         }
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span><span class="lineCov">         61 :         if(csiz-&gt;effective_bits &gt;= 0) {</span>
<span class="lineNum">    1741 </span><span class="lineCov">         48 :                 FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    1742 </span><span class="lineCov">         48 :                 if(bpc) {</span>
<span class="lineNum">    1743 </span><span class="lineCov">         35 :                         st-&gt;size = csiz-&gt;upper_bound * bpc;</span>
<span class="lineNum">    1744 </span>            :                 } else {
<span class="lineNum">    1745 </span><span class="lineCov">         13 :                         st-&gt;size = (csiz-&gt;upper_bound + 7) &gt;&gt; 3;</span>
<span class="lineNum">    1746 </span>            :                 }
<span class="lineNum">    1747 </span><span class="lineCov">         48 :                 st-&gt;buf = (uint8_t *)MALLOC(st-&gt;size + 1);</span>
<span class="lineNum">    1748 </span><span class="lineCov">         48 :                 if(!st-&gt;buf) { st-&gt;size = 0; RETURN(RC_FAIL); }</span>
<span class="lineNum">    1749 </span>            :         }
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span>            :         /* X.691, #16.5: zero-length encoding */
<span class="lineNum">    1752 </span>            :         /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
<span class="lineNum">    1753 </span>            :         /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
<span class="lineNum">    1754 </span><span class="lineCov">         61 :         if(csiz-&gt;effective_bits == 0) {</span>
<span class="lineNum">    1755 </span>            :                 int ret;
<span class="lineNum">    1756 </span><span class="lineCov">         46 :                 if (st-&gt;size &gt; 2) { /* X.691 #16 NOTE 1 */</span>
<span class="lineNum">    1757 </span><span class="lineCov">         35 :                         if (aper_get_align(pd) &lt; 0)</span>
<span class="lineNum">    1758 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">    1759 </span>            :                 }
<span class="lineNum">    1760 </span><span class="lineCov">         46 :                 if(bpc) {</span>
<span class="lineNum">    1761 </span>            :                         ASN_DEBUG(&quot;Decoding OCTET STRING size %ld&quot;,
<span class="lineNum">    1762 </span>            :                                 csiz-&gt;upper_bound);
<span class="lineNum">    1763 </span><span class="lineCov">         70 :                         ret = OCTET_STRING_per_get_characters(pd, st-&gt;buf,</span>
<span class="lineNum">    1764 </span><span class="lineCov">         35 :                                 csiz-&gt;upper_bound, bpc, unit_bits,</span>
<span class="lineNum">    1765 </span>            :                                 cval-&gt;lower_bound, cval-&gt;upper_bound, pc);
<span class="lineNum">    1766 </span><span class="lineCov">         35 :                         if(ret &gt; 0) RETURN(RC_FAIL);</span>
<span class="lineNum">    1767 </span>            :                 } else {
<span class="lineNum">    1768 </span>            :                         ASN_DEBUG(&quot;Decoding BIT STRING size %ld&quot;,
<span class="lineNum">    1769 </span>            :                                 csiz-&gt;upper_bound);
<span class="lineNum">    1770 </span><span class="lineCov">         11 :                         ret = per_get_many_bits(pd, st-&gt;buf, 0,</span>
<span class="lineNum">    1771 </span>            :                                             unit_bits * csiz-&gt;upper_bound);
<span class="lineNum">    1772 </span>            :                 }
<span class="lineNum">    1773 </span><span class="lineCov">         46 :                 if(ret &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1774 </span><span class="lineCov">         46 :                 consumed_myself += unit_bits * csiz-&gt;upper_bound;</span>
<span class="lineNum">    1775 </span><span class="lineCov">         46 :                 st-&gt;buf[st-&gt;size] = 0;</span>
<span class="lineNum">    1776 </span><span class="lineCov">         46 :                 if(bpc == 0) {</span>
<span class="lineNum">    1777 </span><span class="lineCov">         11 :                         int ubs = (csiz-&gt;upper_bound &amp; 0x7);</span>
<span class="lineNum">    1778 </span><span class="lineCov">         11 :                         st-&gt;bits_unused = ubs ? 8 - ubs : 0;</span>
<span class="lineNum">    1779 </span>            :                 }
<span class="lineNum">    1780 </span><span class="lineCov">         46 :                 RETURN(RC_OK);</span>
<span class="lineNum">    1781 </span>            :         }
<span class="lineNum">    1782 </span>            : 
<span class="lineNum">    1783 </span><span class="lineCov">         15 :         st-&gt;size = 0;</span>
<span class="lineNum">    1784 </span>            :         do {
<span class="lineNum">    1785 </span>            :                 ssize_t raw_len;
<span class="lineNum">    1786 </span>            :                 ssize_t len_bytes;
<span class="lineNum">    1787 </span>            :                 ssize_t len_bits;
<span class="lineNum">    1788 </span>            :                 void *p;
<span class="lineNum">    1789 </span>            :                 int ret;
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span>            :                 /* Get the PER length */
<span class="lineNum">    1792 </span><span class="lineCov">         15 :                 if (csiz-&gt;upper_bound - csiz-&gt;lower_bound == 0)</span>
<span class="lineNum">    1793 </span>            :                         /* Indefinite length case */
<span class="lineNum">    1794 </span><span class="lineCov">         13 :                         raw_len = aper_get_length(pd, -1, csiz-&gt;effective_bits, &amp;repeat);</span>
<span class="lineNum">    1795 </span>            :                 else
<span class="lineNum">    1796 </span><span class="lineCov">          2 :                         raw_len = aper_get_length(pd, csiz-&gt;upper_bound - csiz-&gt;lower_bound + 1, csiz-&gt;effective_bits, &amp;repeat);</span>
<span class="lineNum">    1797 </span><span class="lineCov">         15 :                 repeat = 0;</span>
<span class="lineNum">    1798 </span><span class="lineCov">         15 :                 if(raw_len &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1799 </span><span class="lineCov">         15 :                 raw_len += csiz-&gt;lower_bound;</span>
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span>            :                 ASN_DEBUG(&quot;Got PER length eb %ld, len %ld, %s (%s)&quot;,
<span class="lineNum">    1802 </span>            :                         (long)csiz-&gt;effective_bits, (long)raw_len,
<span class="lineNum">    1803 </span>            :                         repeat ? &quot;repeat&quot; : &quot;once&quot;, td-&gt;name);
<span class="lineNum">    1804 </span>            : 
<span class="lineNum">    1805 </span><span class="lineCov">         15 :                 if (raw_len &gt; 2) { /* X.691 #16 NOTE 1 */</span>
<span class="lineNum">    1806 </span><span class="lineCov">         15 :                         if (aper_get_align(pd) &lt; 0)</span>
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :                                 RETURN(RC_FAIL);</span>
<span class="lineNum">    1808 </span>            :                 }
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span><span class="lineCov">         15 :                 if(bpc) {</span>
<span class="lineNum">    1811 </span><span class="lineCov">         13 :                         len_bytes = raw_len * bpc;</span>
<span class="lineNum">    1812 </span><span class="lineCov">         13 :                         len_bits = len_bytes * unit_bits;</span>
<span class="lineNum">    1813 </span>            :                 } else {
<span class="lineNum">    1814 </span><span class="lineCov">          2 :                         len_bits = raw_len;</span>
<span class="lineNum">    1815 </span><span class="lineCov">          2 :                         len_bytes = (len_bits + 7) &gt;&gt; 3;</span>
<span class="lineNum">    1816 </span><span class="lineCov">          2 :                         if(len_bits &amp; 0x7)</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :                                 st-&gt;bits_unused = 8 - (len_bits &amp; 0x7);</span>
<span class="lineNum">    1818 </span>            :                         /* len_bits be multiple of 16K if repeat is set */
<span class="lineNum">    1819 </span>            :                 }
<span class="lineNum">    1820 </span><span class="lineCov">         15 :                 p = REALLOC(st-&gt;buf, st-&gt;size + len_bytes + 1);</span>
<span class="lineNum">    1821 </span><span class="lineCov">         15 :                 if(!p) RETURN(RC_FAIL);</span>
<span class="lineNum">    1822 </span><span class="lineCov">         15 :                 st-&gt;buf = (uint8_t *)p;</span>
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span><span class="lineCov">         15 :                 if(bpc) {</span>
<span class="lineNum">    1825 </span><span class="lineCov">         26 :                         ret = OCTET_STRING_per_get_characters(pd,</span>
<span class="lineNum">    1826 </span><span class="lineCov">         13 :                                 &amp;st-&gt;buf[st-&gt;size], raw_len, bpc, unit_bits,</span>
<span class="lineNum">    1827 </span>            :                                 cval-&gt;lower_bound, cval-&gt;upper_bound, pc);
<span class="lineNum">    1828 </span><span class="lineCov">         13 :                         if(ret &gt; 0) RETURN(RC_FAIL);</span>
<span class="lineNum">    1829 </span>            :                 } else {
<span class="lineNum">    1830 </span><span class="lineCov">          2 :                         ret = per_get_many_bits(pd, &amp;st-&gt;buf[st-&gt;size],</span>
<span class="lineNum">    1831 </span>            :                                 0, len_bits);
<span class="lineNum">    1832 </span>            :                 }
<span class="lineNum">    1833 </span><span class="lineCov">         15 :                 if(ret &lt; 0) RETURN(RC_WMORE);</span>
<span class="lineNum">    1834 </span><span class="lineCov">         15 :                 st-&gt;size += len_bytes;</span>
<span class="lineNum">    1835 </span><span class="lineCov">         15 :         } while(repeat);</span>
<span class="lineNum">    1836 </span><span class="lineCov">         15 :         st-&gt;buf[st-&gt;size] = 0;    /* nul-terminate */</span>
<span class="lineNum">    1837 </span>            : 
<span class="lineNum">    1838 </span><span class="lineCov">         15 :         return rval;</span>
<span class="lineNum">    1839 </span>            : }
<a name="1840"><span class="lineNum">    1840 </span>            : </a>
<span class="lineNum">    1841 </span>            : asn_enc_rval_t
<span class="lineNum">    1842 </span><span class="lineCov">         34 : OCTET_STRING_encode_aper(const asn_TYPE_descriptor_t *td,</span>
<span class="lineNum">    1843 </span>            :                          const asn_per_constraints_t *constraints,
<span class="lineNum">    1844 </span>            :                          const void *sptr, asn_per_outp_t *po) {
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineCov">         68 :         const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    1847 </span>            :                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    1848 </span><span class="lineCov">         34 :                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    1849 </span><span class="lineCov">         34 :         const asn_per_constraints_t *pc = constraints ? constraints</span>
<span class="lineNum">    1850 </span><span class="lineCov">         34 :         : td-&gt;encoding_constraints.per_constraints;</span>
<span class="lineNum">    1851 </span>            :         const asn_per_constraint_t *cval;
<span class="lineNum">    1852 </span>            :         const asn_per_constraint_t *csiz;
<span class="lineNum">    1853 </span><span class="lineCov">         34 :         const BIT_STRING_t *st = (const BIT_STRING_t *)sptr;</span>
<span class="lineNum">    1854 </span><span class="lineCov">         34 :         asn_enc_rval_t er = { 0, 0, 0 };</span>
<span class="lineNum">    1855 </span><span class="lineCov">         34 :         int inext = 0;          /* Lies not within extension root */</span>
<span class="lineNum">    1856 </span>            :         unsigned int unit_bits;
<span class="lineNum">    1857 </span>            :         unsigned int canonical_unit_bits;
<span class="lineNum">    1858 </span>            :         unsigned int sizeinunits;
<span class="lineNum">    1859 </span>            :         const uint8_t *buf;
<span class="lineNum">    1860 </span>            :         int ret;
<span class="lineNum">    1861 </span>            :         enum {
<span class="lineNum">    1862 </span>            :                 OS__BPC_BIT     = 0,
<span class="lineNum">    1863 </span>            :                 OS__BPC_CHAR    = 1,
<span class="lineNum">    1864 </span>            :                 OS__BPC_U16     = 2,
<span class="lineNum">    1865 </span>            :                 OS__BPC_U32     = 4
<span class="lineNum">    1866 </span>            :         } bpc;  /* Bytes per character */
<span class="lineNum">    1867 </span>            :         int ct_extensible;
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span><span class="lineCov">         34 :         if(!st || (!st-&gt;buf &amp;&amp; st-&gt;size))</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1871 </span>            : 
<span class="lineNum">    1872 </span><span class="lineCov">         34 :         if(pc) {</span>
<span class="lineNum">    1873 </span><span class="lineCov">         25 :                 cval = &amp;pc-&gt;value;</span>
<span class="lineNum">    1874 </span><span class="lineCov">         25 :                 csiz = &amp;pc-&gt;size;</span>
<span class="lineNum">    1875 </span>            :         } else {
<span class="lineNum">    1876 </span><span class="lineCov">          9 :                 cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1877 </span><span class="lineCov">          9 :                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1878 </span>            :         }
<span class="lineNum">    1879 </span><span class="lineCov">         34 :         ct_extensible = csiz-&gt;flags &amp; APC_EXTENSIBLE;</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span><span class="lineCov">         34 :         switch(specs-&gt;subvariant) {</span>
<span class="lineNum">    1882 </span>            :                 default:
<span class="lineNum">    1883 </span>            :                         /*         case ASN_OSUBV_ANY:
<span class="lineNum">    1884 </span>            :                                          ASN__ENCODE_FAILED;
<span class="lineNum">    1885 </span>            :                         */
<span class="lineNum">    1886 </span>            :                 case ASN_OSUBV_BIT:
<span class="lineNum">    1887 </span><span class="lineCov">          8 :                         canonical_unit_bits = unit_bits = 1;</span>
<span class="lineNum">    1888 </span><span class="lineCov">          8 :                         bpc = OS__BPC_BIT;</span>
<span class="lineNum">    1889 </span><span class="lineCov">          8 :                         sizeinunits = st-&gt;size * 8 - (st-&gt;bits_unused &amp; 0x07);</span>
<span class="lineNum">    1890 </span>            :                         ASN_DEBUG(&quot;BIT STRING of %d bytes&quot;,
<span class="lineNum">    1891 </span>            :                                                                 sizeinunits);
<span class="lineNum">    1892 </span><span class="lineCov">          8 :                 break;</span>
<span class="lineNum">    1893 </span>            :         case ASN_OSUBV_ANY:
<span class="lineNum">    1894 </span>            :         case ASN_OSUBV_STR:
<span class="lineNum">    1895 </span><span class="lineCov">         26 :                 canonical_unit_bits = unit_bits = 8;</span>
<span class="lineNum">    1896 </span>            : /*              if(cval-&gt;flags &amp; APC_CONSTRAINED)
<span class="lineNum">    1897 </span>            :                         unit_bits = 8;
<span class="lineNum">    1898 </span>            : */
<span class="lineNum">    1899 </span><span class="lineCov">         26 :                 bpc = OS__BPC_CHAR;</span>
<span class="lineNum">    1900 </span><span class="lineCov">         26 :                 sizeinunits = st-&gt;size;</span>
<span class="lineNum">    1901 </span><span class="lineCov">         26 :                 break;</span>
<span class="lineNum">    1902 </span>            :         case ASN_OSUBV_U16:
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 16;</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U16;</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :                 sizeinunits = st-&gt;size / 2;</span>
<span class="lineNum">    1908 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1909 </span>            :         case ASN_OSUBV_U32:
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :                 canonical_unit_bits = unit_bits = 32;</span>
<span class="lineNum">    1911 </span><span class="lineNoCov">          0 :                 if(cval-&gt;flags &amp; APC_CONSTRAINED)</span>
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :                         unit_bits = cval-&gt;range_bits;</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :                 bpc = OS__BPC_U32;</span>
<span class="lineNum">    1914 </span><span class="lineNoCov">          0 :                 sizeinunits = st-&gt;size / 4;</span>
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    1916 </span>            :         }
<span class="lineNum">    1917 </span>            : 
<span class="lineNum">    1918 </span>            :         ASN_DEBUG(&quot;Encoding %s into %d units of %d bits&quot;
<span class="lineNum">    1919 </span>            :                 &quot; (%ld..%ld, effective %d)%s&quot;,
<span class="lineNum">    1920 </span>            :                 td-&gt;name, sizeinunits, unit_bits,
<span class="lineNum">    1921 </span>            :                 csiz-&gt;lower_bound, csiz-&gt;upper_bound,
<span class="lineNum">    1922 </span>            :                 csiz-&gt;effective_bits, ct_extensible ? &quot; EXT&quot; : &quot;&quot;);
<span class="lineNum">    1923 </span>            : 
<span class="lineNum">    1924 </span>            :         /* Figure out wheter size lies within PER visible constraint */
<span class="lineNum">    1925 </span>            : 
<span class="lineNum">    1926 </span><span class="lineCov">         34 :         if(csiz-&gt;effective_bits &gt;= 0) {</span>
<span class="lineNum">    1927 </span><span class="lineCov">         25 :                 if((int)sizeinunits &lt; csiz-&gt;lower_bound</span>
<span class="lineNum">    1928 </span><span class="lineCov">         25 :                 || (int)sizeinunits &gt; csiz-&gt;upper_bound) {</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :                         if(ct_extensible) {</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :                                 cval = &amp;asn_DEF_OCTET_STRING_constraints.value;</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :                                 csiz = &amp;asn_DEF_OCTET_STRING_constraints.size;</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :                                 unit_bits = canonical_unit_bits;</span>
<span class="lineNum">    1933 </span><span class="lineNoCov">          0 :                                 inext = 1;</span>
<span class="lineNum">    1934 </span>            :                         } else
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 :                                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1936 </span>            :                 }
<span class="lineNum">    1937 </span>            :         } else {
<span class="lineNum">    1938 </span><span class="lineCov">          9 :                 inext = 0;</span>
<span class="lineNum">    1939 </span>            :         }
<span class="lineNum">    1940 </span>            : 
<span class="lineNum">    1941 </span>            : 
<span class="lineNum">    1942 </span><span class="lineCov">         34 :         if(ct_extensible) {</span>
<span class="lineNum">    1943 </span>            :                 /* Declare whether length is [not] within extension root */
<span class="lineNum">    1944 </span><span class="lineCov">          6 :                 if(per_put_few_bits(po, inext, 1))</span>
<span class="lineNum">    1945 </span><span class="lineNoCov">          0 :                         ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1946 </span>            :         }
<span class="lineNum">    1947 </span>            : 
<span class="lineNum">    1948 </span>            :         /* X.691, #16.5: zero-length encoding */
<span class="lineNum">    1949 </span>            :         /* X.691, #16.6: short fixed length encoding (up to 2 octets) */
<span class="lineNum">    1950 </span>            :         /* X.691, #16.7: long fixed length encoding (up to 64K octets) */
<span class="lineNum">    1951 </span><span class="lineCov">         34 :         if(csiz-&gt;effective_bits &gt;= 0) {</span>
<span class="lineNum">    1952 </span>            :                 ASN_DEBUG(&quot;Encoding %lu bytes (%ld), length in %d bits&quot;,
<span class="lineNum">    1953 </span>            :                                 st-&gt;size, sizeinunits - csiz-&gt;lower_bound,
<span class="lineNum">    1954 </span>            :                                 csiz-&gt;effective_bits);
<span class="lineNum">    1955 </span><span class="lineCov">         25 :                 if (csiz-&gt;effective_bits &gt; 0) {</span>
<span class="lineNum">    1956 </span><span class="lineCov">          2 :                         ret = aper_put_length(po, csiz-&gt;upper_bound - csiz-&gt;lower_bound + 1, sizeinunits - csiz-&gt;lower_bound);</span>
<span class="lineNum">    1957 </span><span class="lineCov">          2 :                         if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1958 </span>            :                 }
<span class="lineNum">    1959 </span><span class="lineCov">         25 :                 if (st-&gt;size &gt; 2) { /* X.691 #16 NOTE 1 */</span>
<span class="lineNum">    1960 </span><span class="lineCov">         11 :                         if (aper_put_align(po) &lt; 0)</span>
<span class="lineNum">    1961 </span><span class="lineNoCov">          0 :                                 ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1962 </span>            :                 }
<span class="lineNum">    1963 </span><span class="lineCov">         25 :                 if(bpc) {</span>
<span class="lineNum">    1964 </span><span class="lineCov">         17 :                         ret = OCTET_STRING_per_put_characters(po, st-&gt;buf,</span>
<span class="lineNum">    1965 </span>            :                                 sizeinunits, bpc, unit_bits,
<span class="lineNum">    1966 </span>            :                                 cval-&gt;lower_bound, cval-&gt;upper_bound, pc);
<span class="lineNum">    1967 </span>            :                 } else {
<span class="lineNum">    1968 </span><span class="lineCov">          8 :                         ret = per_put_many_bits(po, st-&gt;buf,</span>
<span class="lineNum">    1969 </span>            :                                 sizeinunits * unit_bits);
<span class="lineNum">    1970 </span>            :                 }
<span class="lineNum">    1971 </span><span class="lineCov">         25 :                 if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1972 </span><span class="lineCov">         25 :                 ASN__ENCODED_OK(er);</span>
<span class="lineNum">    1973 </span>            :         }
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            :         ASN_DEBUG(&quot;Encoding %lu bytes&quot;, st-&gt;size);
<span class="lineNum">    1976 </span>            : 
<span class="lineNum">    1977 </span><span class="lineCov">          9 :         if(sizeinunits == 0) {</span>
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :                 if(aper_put_length(po, -1, 0))</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :                         ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :                 ASN__ENCODED_OK(er);</span>
<span class="lineNum">    1981 </span>            :         }
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineCov">          9 :         buf = st-&gt;buf;</span>
<span class="lineNum">    1984 </span><span class="lineCov">         27 :         while(sizeinunits) {</span>
<span class="lineNum">    1985 </span><span class="lineCov">          9 :                 ssize_t maySave = aper_put_length(po, -1, sizeinunits);</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineCov">          9 :                 if(maySave &lt; 0) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span>            :                 ASN_DEBUG(&quot;Encoding %ld of %ld&quot;,
<span class="lineNum">    1990 </span>            :                         (long)maySave, (long)sizeinunits);
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span><span class="lineCov">          9 :                 if(bpc) {</span>
<span class="lineNum">    1993 </span><span class="lineCov">          9 :                         ret = OCTET_STRING_per_put_characters(po, buf,</span>
<span class="lineNum">    1994 </span>            :                                 maySave, bpc, unit_bits,
<span class="lineNum">    1995 </span>            :                                 cval-&gt;lower_bound, cval-&gt;upper_bound, pc);
<span class="lineNum">    1996 </span>            :                 } else {
<span class="lineNum">    1997 </span><span class="lineNoCov">          0 :                         ret = per_put_many_bits(po, buf, maySave * unit_bits);</span>
<span class="lineNum">    1998 </span>            :                 }
<span class="lineNum">    1999 </span><span class="lineCov">          9 :                 if(ret) ASN__ENCODE_FAILED;</span>
<span class="lineNum">    2000 </span>            : 
<span class="lineNum">    2001 </span><span class="lineCov">          9 :                 if(bpc)</span>
<span class="lineNum">    2002 </span><span class="lineCov">          9 :                         buf += maySave * bpc;</span>
<span class="lineNum">    2003 </span>            :                 else
<span class="lineNum">    2004 </span><span class="lineNoCov">          0 :                         buf += maySave &gt;&gt; 3;</span>
<span class="lineNum">    2005 </span><span class="lineCov">          9 :                 sizeinunits -= maySave;</span>
<span class="lineNum">    2006 </span><span class="lineCov">          9 :                 assert(!(maySave &amp; 0x07) || !sizeinunits);</span>
<span class="lineNum">    2007 </span>            :         }
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineCov">          9 :         ASN__ENCODED_OK(er);</span>
<span class="lineNum">    2010 </span>            : }
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span>            : #endif  /* ASN_DISABLE_PER_SUPPORT */
<a name="2013"><span class="lineNum">    2013 </span>            : </a>
<span class="lineNum">    2014 </span>            : int
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 : OCTET_STRING_print(const asn_TYPE_descriptor_t *td, const void *sptr,</span>
<span class="lineNum">    2016 </span>            :                    int ilevel, asn_app_consume_bytes_f *cb, void *app_key) {
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :     const char * const h2c = &quot;0123456789ABCDEF&quot;;</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :         const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;</span>
<span class="lineNum">    2019 </span>            :         char scratch[16 * 3 + 4];
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :         char *p = scratch;</span>
<span class="lineNum">    2021 </span>            :         uint8_t *buf;
<span class="lineNum">    2022 </span>            :         uint8_t *end;
<span class="lineNum">    2023 </span>            :         size_t i;
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            :         (void)td;       /* Unused argument */
<span class="lineNum">    2026 </span>            : 
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :         if(!st || (!st-&gt;buf &amp;&amp; st-&gt;size))</span>
<span class="lineNum">    2028 </span><span class="lineNoCov">          0 :                 return (cb(&quot;&lt;absent&gt;&quot;, 8, app_key) &lt; 0) ? -1 : 0;</span>
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span>            :         /*
<span class="lineNum">    2031 </span>            :          * Dump the contents of the buffer in hexadecimal.
<span class="lineNum">    2032 </span>            :          */
<span class="lineNum">    2033 </span><span class="lineNoCov">          0 :         buf = st-&gt;buf;</span>
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :         end = buf + st-&gt;size;</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :         for(i = 0; buf &lt; end; buf++, i++) {</span>
<span class="lineNum">    2036 </span><span class="lineNoCov">          0 :                 if(!(i % 16) &amp;&amp; (i || st-&gt;size &gt; 16)) {</span>
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :                         if(cb(scratch, p - scratch, app_key) &lt; 0)</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :                                 return -1;</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                         _i_INDENT(1);</span>
<span class="lineNum">    2040 </span><span class="lineNoCov">          0 :                         p = scratch;</span>
<span class="lineNum">    2041 </span>            :                 }
<span class="lineNum">    2042 </span><span class="lineNoCov">          0 :                 *p++ = h2c[(*buf &gt;&gt; 4) &amp; 0x0F];</span>
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :                 *p++ = h2c[*buf &amp; 0x0F];</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :                 *p++ = 0x20;</span>
<span class="lineNum">    2045 </span>            :         }
<span class="lineNum">    2046 </span>            : 
<span class="lineNum">    2047 </span><span class="lineNoCov">          0 :         if(p &gt; scratch) {</span>
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :                 p--;    /* Remove the tail space */</span>
<span class="lineNum">    2049 </span><span class="lineNoCov">          0 :                 if(cb(scratch, p - scratch, app_key) &lt; 0)</span>
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :                         return -1;</span>
<span class="lineNum">    2051 </span>            :         }
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2054 </span>            : }
<a name="2055"><span class="lineNum">    2055 </span>            : </a>
<span class="lineNum">    2056 </span>            : int
<span class="lineNum">    2057 </span><span class="lineNoCov">          0 : OCTET_STRING_print_utf8(const asn_TYPE_descriptor_t *td, const void *sptr,</span>
<span class="lineNum">    2058 </span>            :                         int ilevel, asn_app_consume_bytes_f *cb,
<span class="lineNum">    2059 </span>            :                         void *app_key) {
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 :     const OCTET_STRING_t *st = (const OCTET_STRING_t *)sptr;</span>
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span>            :         (void)td;       /* Unused argument */
<span class="lineNum">    2063 </span>            :         (void)ilevel;   /* Unused argument */
<span class="lineNum">    2064 </span>            : 
<span class="lineNum">    2065 </span><span class="lineNoCov">          0 :         if(st &amp;&amp; (st-&gt;buf || !st-&gt;size)) {</span>
<span class="lineNum">    2066 </span><span class="lineNoCov">          0 :                 return (cb(st-&gt;buf, st-&gt;size, app_key) &lt; 0) ? -1 : 0;</span>
<span class="lineNum">    2067 </span>            :         } else {
<span class="lineNum">    2068 </span><span class="lineNoCov">          0 :                 return (cb(&quot;&lt;absent&gt;&quot;, 8, app_key) &lt; 0) ? -1 : 0;</span>
<span class="lineNum">    2069 </span>            :         }
<span class="lineNum">    2070 </span>            : }
<a name="2071"><span class="lineNum">    2071 </span>            : </a>
<span class="lineNum">    2072 </span>            : void
<span class="lineNum">    2073 </span><span class="lineCov">         95 : OCTET_STRING_free(const asn_TYPE_descriptor_t *td, void *sptr,</span>
<span class="lineNum">    2074 </span>            :                   enum asn_struct_free_method method) {
<span class="lineNum">    2075 </span><span class="lineCov">         95 :         OCTET_STRING_t *st = (OCTET_STRING_t *)sptr;</span>
<span class="lineNum">    2076 </span>            :         const asn_OCTET_STRING_specifics_t *specs;
<span class="lineNum">    2077 </span>            :         asn_struct_ctx_t *ctx;
<span class="lineNum">    2078 </span>            :         struct _stack *stck;
<span class="lineNum">    2079 </span>            : 
<span class="lineNum">    2080 </span><span class="lineCov">         95 :         if(!td || !st)</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                 return;</span>
<span class="lineNum">    2082 </span>            : 
<span class="lineNum">    2083 </span><span class="lineCov">        190 :         specs = td-&gt;specifics</span>
<span class="lineNum">    2084 </span>            :                     ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    2085 </span><span class="lineCov">         95 :                     : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    2086 </span><span class="lineCov">         95 :         ctx = (asn_struct_ctx_t *)((char *)st + specs-&gt;ctx_offset);</span>
<span class="lineNum">    2087 </span>            : 
<span class="lineNum">    2088 </span>            :         ASN_DEBUG(&quot;Freeing %s as OCTET STRING&quot;, td-&gt;name);
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span><span class="lineCov">         95 :         if(st-&gt;buf) {</span>
<span class="lineNum">    2091 </span><span class="lineCov">         95 :                 FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    2092 </span><span class="lineCov">         95 :                 st-&gt;buf = 0;</span>
<span class="lineNum">    2093 </span>            :         }
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span>            :         /*
<span class="lineNum">    2096 </span>            :          * Remove decode-time stack.
<span class="lineNum">    2097 </span>            :          */
<span class="lineNum">    2098 </span><span class="lineCov">         95 :         stck = (struct _stack *)ctx-&gt;ptr;</span>
<span class="lineNum">    2099 </span><span class="lineCov">         95 :         if(stck) {</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :                 while(stck-&gt;tail) {</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :                         struct _stack_el *sel = stck-&gt;tail;</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :                         stck-&gt;tail = sel-&gt;prev;</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :                         FREEMEM(sel);</span>
<span class="lineNum">    2104 </span>            :                 }
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :                 FREEMEM(stck);</span>
<span class="lineNum">    2106 </span>            :         }
<span class="lineNum">    2107 </span>            : 
<span class="lineNum">    2108 </span><span class="lineCov">         95 :     switch(method) {</span>
<span class="lineNum">    2109 </span>            :     case ASFM_FREE_EVERYTHING:
<span class="lineNum">    2110 </span><span class="lineCov">         18 :         FREEMEM(sptr);</span>
<span class="lineNum">    2111 </span><span class="lineCov">         18 :         break;</span>
<span class="lineNum">    2112 </span>            :     case ASFM_FREE_UNDERLYING:
<span class="lineNum">    2113 </span><span class="lineCov">         77 :         break;</span>
<span class="lineNum">    2114 </span>            :     case ASFM_FREE_UNDERLYING_AND_RESET:
<span class="lineNum">    2115 </span><span class="lineNoCov">          0 :         memset(sptr, 0,</span>
<span class="lineNum">    2116 </span><span class="lineNoCov">          0 :                td-&gt;specifics</span>
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :                    ? ((const asn_OCTET_STRING_specifics_t *)(td-&gt;specifics))</span>
<span class="lineNum">    2118 </span><span class="lineNoCov">          0 :                          -&gt;struct_size</span>
<span class="lineNum">    2119 </span>            :                    : sizeof(OCTET_STRING_t));
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2121 </span>            :     }
<span class="lineNum">    2122 </span>            : }
<span class="lineNum">    2123 </span>            : 
<span class="lineNum">    2124 </span>            : /*
<span class="lineNum">    2125 </span>            :  * Conversion routines.
<a name="2126"><span class="lineNum">    2126 </span>            :  */</a>
<span class="lineNum">    2127 </span>            : int
<span class="lineNum">    2128 </span><span class="lineCov">          7 : OCTET_STRING_fromBuf(OCTET_STRING_t *st, const char *str, int len) {</span>
<span class="lineNum">    2129 </span>            :         void *buf;
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span><span class="lineCov">          7 :         if(st == 0 || (str == 0 &amp;&amp; len)) {</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :                 errno = EINVAL;</span>
<span class="lineNum">    2133 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2134 </span>            :         }
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span>            :         /*
<span class="lineNum">    2137 </span>            :          * Clear the OCTET STRING.
<span class="lineNum">    2138 </span>            :          */
<span class="lineNum">    2139 </span><span class="lineCov">          7 :         if(str == NULL) {</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :                 FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :                 st-&gt;buf = 0;</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :                 st-&gt;size = 0;</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2144 </span>            :         }
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            :         /* Determine the original string size, if not explicitly given */
<span class="lineNum">    2147 </span><span class="lineCov">          7 :         if(len &lt; 0)</span>
<span class="lineNum">    2148 </span><span class="lineNoCov">          0 :                 len = strlen(str);</span>
<span class="lineNum">    2149 </span>            : 
<span class="lineNum">    2150 </span>            :         /* Allocate and fill the memory */
<span class="lineNum">    2151 </span><span class="lineCov">          7 :         buf = MALLOC(len + 1);</span>
<span class="lineNum">    2152 </span><span class="lineCov">          7 :         if(buf == NULL)</span>
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span><span class="lineCov">          7 :         memcpy(buf, str, len);</span>
<span class="lineNum">    2156 </span><span class="lineCov">          7 :         ((uint8_t *)buf)[len] = '\0';   /* Couldn't use memcpy(len+1)! */</span>
<span class="lineNum">    2157 </span><span class="lineCov">          7 :         FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    2158 </span><span class="lineCov">          7 :         st-&gt;buf = (uint8_t *)buf;</span>
<span class="lineNum">    2159 </span><span class="lineCov">          7 :         st-&gt;size = len;</span>
<span class="lineNum">    2160 </span>            : 
<span class="lineNum">    2161 </span><span class="lineCov">          7 :         return 0;</span>
<span class="lineNum">    2162 </span>            : }
<a name="2163"><span class="lineNum">    2163 </span>            : </a>
<span class="lineNum">    2164 </span>            : OCTET_STRING_t *
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 : OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str,</span>
<span class="lineNum">    2166 </span>            :                          int len) {
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :     const asn_OCTET_STRING_specifics_t *specs =</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :         td-&gt;specifics ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :                       : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    2170 </span>            :     OCTET_STRING_t *st;
<span class="lineNum">    2171 </span>            : 
<span class="lineNum">    2172 </span><span class="lineNoCov">          0 :         st = (OCTET_STRING_t *)CALLOC(1, specs-&gt;struct_size);</span>
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :         if(st &amp;&amp; str &amp;&amp; OCTET_STRING_fromBuf(st, str, len)) {</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :                 FREEMEM(st);</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :                 st = NULL;</span>
<span class="lineNum">    2176 </span>            :         }
<span class="lineNum">    2177 </span>            : 
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :         return st;</span>
<span class="lineNum">    2179 </span>            : }
<span class="lineNum">    2180 </span>            : 
<span class="lineNum">    2181 </span>            : /*
<span class="lineNum">    2182 </span>            :  * Lexicographically compare the common prefix of both strings,
<span class="lineNum">    2183 </span>            :  * and if it is the same return -1 for the smallest string.
<a name="2184"><span class="lineNum">    2184 </span>            :  */</a>
<span class="lineNum">    2185 </span>            : int
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 : OCTET_STRING_compare(const asn_TYPE_descriptor_t *td, const void *aptr,</span>
<span class="lineNum">    2187 </span>            :                      const void *bptr) {
<span class="lineNum">    2188 </span><span class="lineNoCov">          0 :     const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics;</span>
<span class="lineNum">    2189 </span><span class="lineNoCov">          0 :     const OCTET_STRING_t *a = aptr;</span>
<span class="lineNum">    2190 </span><span class="lineNoCov">          0 :     const OCTET_STRING_t *b = bptr;</span>
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :     assert(!specs || specs-&gt;subvariant != ASN_OSUBV_BIT);</span>
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :     if(a &amp;&amp; b) {</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :         size_t common_prefix_size = a-&gt;size &lt;= b-&gt;size ? a-&gt;size : b-&gt;size;</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         int ret = memcmp(a-&gt;buf, b-&gt;buf, common_prefix_size);</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :         if(ret == 0) {</span>
<span class="lineNum">    2198 </span>            :             /* Figure out which string with equal prefixes is longer. */
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :             if(a-&gt;size &lt; b-&gt;size) {</span>
<span class="lineNum">    2200 </span><span class="lineNoCov">          0 :                 return -1;</span>
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :             } else if(a-&gt;size &gt; b-&gt;size) {</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :                 return 1;</span>
<span class="lineNum">    2203 </span>            :             } else {
<span class="lineNum">    2204 </span><span class="lineNoCov">          0 :                 return 0;</span>
<span class="lineNum">    2205 </span>            :             }
<span class="lineNum">    2206 </span>            :         } else {
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :             return ret &lt; 0 ? -1 : 1;</span>
<span class="lineNum">    2208 </span>            :         }
<span class="lineNum">    2209 </span><span class="lineNoCov">          0 :     } else if(!a &amp;&amp; !b) {</span>
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :         return 0;</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :     } else if(!a) {</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :         return -1;</span>
<span class="lineNum">    2213 </span>            :     } else {
<span class="lineNum">    2214 </span><span class="lineNoCov">          0 :         return 1;</span>
<span class="lineNum">    2215 </span>            :     }
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span>            : }
<span class="lineNum">    2218 </span>            : 
<span class="lineNum">    2219 </span>            : /*
<span class="lineNum">    2220 </span>            :  * Biased function for randomizing character values around their limits.
<a name="2221"><span class="lineNum">    2221 </span>            :  */</a>
<span class="lineNum">    2222 </span>            : static uint32_t
<span class="lineNum">    2223 </span><span class="lineNoCov">          0 : OCTET_STRING__random_char(unsigned long lb, unsigned long ub) {</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     assert(lb &lt;= ub);</span>
<span class="lineNum">    2225 </span><span class="lineNoCov">          0 :     switch(asn_random_between(0, 16)) {</span>
<span class="lineNum">    2226 </span>            :     case 0:
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :         if(lb &lt; ub) return lb + 1;</span>
<span class="lineNum">    2228 </span>            :         /* Fall through */
<span class="lineNum">    2229 </span>            :     case 1:
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :         return lb;</span>
<span class="lineNum">    2231 </span>            :     case 2:
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :         if(lb &lt; ub) return ub - 1;</span>
<span class="lineNum">    2233 </span>            :         /* Fall through */
<span class="lineNum">    2234 </span>            :     case 3:
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :         return ub;</span>
<span class="lineNum">    2236 </span>            :     default:
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :         return asn_random_between(lb, ub);</span>
<span class="lineNum">    2238 </span>            :     }
<span class="lineNum">    2239 </span>            : }
<span class="lineNum">    2240 </span>            : 
<a name="2241"><span class="lineNum">    2241 </span>            : </a>
<span class="lineNum">    2242 </span>            : size_t
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 : OCTET_STRING_random_length_constrained(</span>
<span class="lineNum">    2244 </span>            :     const asn_TYPE_descriptor_t *td,
<span class="lineNum">    2245 </span>            :     const asn_encoding_constraints_t *constraints, size_t max_length) {
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :     const unsigned lengths[] = {0,     1,     2,     3,     4,     8,</span>
<span class="lineNum">    2247 </span>            :                                 126,   127,   128,   16383, 16384, 16385,
<span class="lineNum">    2248 </span>            :                                 65534, 65535, 65536, 65537};
<span class="lineNum">    2249 </span>            :     size_t rnd_len;
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :     /* Figure out how far we should go */
<span class="lineNum">    2252 </span><span class="lineNoCov">          0 :     rnd_len = lengths[asn_random_between(</span>
<span class="lineNum">    2253 </span>            :         0, sizeof(lengths) / sizeof(lengths[0]) - 1)];
<span class="lineNum">    2254 </span>            : 
<span class="lineNum">    2255 </span><span class="lineNoCov">          0 :     if(!constraints || !constraints-&gt;per_constraints)</span>
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :         constraints = &amp;td-&gt;encoding_constraints;</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :     if(constraints-&gt;per_constraints) {</span>
<span class="lineNum">    2258 </span><span class="lineNoCov">          0 :         const asn_per_constraint_t *pc = &amp;constraints-&gt;per_constraints-&gt;size;</span>
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :         if(pc-&gt;flags &amp; APC_CONSTRAINED) {</span>
<span class="lineNum">    2260 </span><span class="lineNoCov">          0 :             long suggested_upper_bound = pc-&gt;upper_bound &lt; (ssize_t)max_length</span>
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :                                              ? pc-&gt;upper_bound</span>
<span class="lineNum">    2262 </span><span class="lineNoCov">          0 :                                              : (ssize_t)max_length;</span>
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :             if(max_length &lt;= (size_t)pc-&gt;lower_bound) {</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                 return pc-&gt;lower_bound;</span>
<span class="lineNum">    2265 </span>            :             }
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :             if(pc-&gt;flags &amp; APC_EXTENSIBLE) {</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                 switch(asn_random_between(0, 5)) {</span>
<span class="lineNum">    2268 </span>            :                 case 0:
<span class="lineNum">    2269 </span><span class="lineNoCov">          0 :                     if(pc-&gt;lower_bound &gt; 0) {</span>
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :                         rnd_len = pc-&gt;lower_bound - 1;</span>
<span class="lineNum">    2271 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2272 </span>            :                     }
<span class="lineNum">    2273 </span>            :                     /* Fall through */
<span class="lineNum">    2274 </span>            :                 case 1:
<span class="lineNum">    2275 </span><span class="lineNoCov">          0 :                     rnd_len = pc-&gt;upper_bound + 1;</span>
<span class="lineNum">    2276 </span><span class="lineNoCov">          0 :                     break;</span>
<span class="lineNum">    2277 </span>            :                 case 2:
<span class="lineNum">    2278 </span>            :                     /* Keep rnd_len from the table */
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :                     if(rnd_len &lt;= max_length) {</span>
<span class="lineNum">    2280 </span><span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">    2281 </span>            :                     }
<span class="lineNum">    2282 </span>            :                     /* Fall through */
<span class="lineNum">    2283 </span>            :                 default:
<span class="lineNum">    2284 </span><span class="lineNoCov">          0 :                     rnd_len = asn_random_between(pc-&gt;lower_bound,</span>
<span class="lineNum">    2285 </span>            :                                                  suggested_upper_bound);
<span class="lineNum">    2286 </span>            :                 }
<span class="lineNum">    2287 </span>            :             } else {
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :                 rnd_len =</span>
<span class="lineNum">    2289 </span><span class="lineNoCov">          0 :                     asn_random_between(pc-&gt;lower_bound, suggested_upper_bound);</span>
<span class="lineNum">    2290 </span>            :             }
<span class="lineNum">    2291 </span>            :         } else {
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :             rnd_len = asn_random_between(0, max_length);</span>
<span class="lineNum">    2293 </span>            :         }
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :     } else if(rnd_len &gt; max_length) {</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :         rnd_len = asn_random_between(0, max_length);</span>
<span class="lineNum">    2296 </span>            :     }
<span class="lineNum">    2297 </span>            : 
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :     return rnd_len;</span>
<span class="lineNum">    2299 </span>            : }
<a name="2300"><span class="lineNum">    2300 </span>            : </a>
<span class="lineNum">    2301 </span>            : asn_random_fill_result_t
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 : OCTET_STRING_random_fill(const asn_TYPE_descriptor_t *td, void **sptr,</span>
<span class="lineNum">    2303 </span>            :                          const asn_encoding_constraints_t *constraints,
<span class="lineNum">    2304 </span>            :                          size_t max_length) {
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :         const asn_OCTET_STRING_specifics_t *specs = td-&gt;specifics</span>
<span class="lineNum">    2306 </span>            :                                 ? (const asn_OCTET_STRING_specifics_t *)td-&gt;specifics
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :                                 : &amp;asn_SPC_OCTET_STRING_specs;</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :     asn_random_fill_result_t result_ok = {ARFILL_OK, 1};</span>
<span class="lineNum">    2309 </span><span class="lineNoCov">          0 :     asn_random_fill_result_t result_failed = {ARFILL_FAILED, 0};</span>
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :     asn_random_fill_result_t result_skipped = {ARFILL_SKIPPED, 0};</span>
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :     unsigned int unit_bytes = 1;</span>
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :     unsigned long clb = 0;  /* Lower bound on char */</span>
<span class="lineNum">    2313 </span><span class="lineNoCov">          0 :     unsigned long cub = 255;  /* Higher bound on char value */</span>
<span class="lineNum">    2314 </span>            :     uint8_t *buf;
<span class="lineNum">    2315 </span>            :     uint8_t *bend;
<span class="lineNum">    2316 </span>            :     uint8_t *b;
<span class="lineNum">    2317 </span>            :     size_t rnd_len;
<span class="lineNum">    2318 </span>            :     OCTET_STRING_t *st;
<span class="lineNum">    2319 </span>            : 
<span class="lineNum">    2320 </span><span class="lineNoCov">          0 :     if(max_length == 0 &amp;&amp; !*sptr) return result_skipped;</span>
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span><span class="lineNoCov">          0 :     switch(specs-&gt;subvariant) {</span>
<span class="lineNum">    2323 </span>            :     default:
<span class="lineNum">    2324 </span>            :     case ASN_OSUBV_ANY:
<span class="lineNum">    2325 </span><span class="lineNoCov">          0 :         return result_failed;</span>
<span class="lineNum">    2326 </span>            :     case ASN_OSUBV_BIT:
<span class="lineNum">    2327 </span>            :         /* Handled by BIT_STRING itself. */
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :         return result_failed;</span>
<span class="lineNum">    2329 </span>            :     case ASN_OSUBV_STR:
<span class="lineNum">    2330 </span><span class="lineNoCov">          0 :         unit_bytes = 1;</span>
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :         clb = 0;</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :         cub = 255;</span>
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2334 </span>            :     case ASN_OSUBV_U16:
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :         unit_bytes = 2;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :         clb = 0;</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :         cub = 65535;</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2339 </span>            :     case ASN_OSUBV_U32:
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :         unit_bytes = 4;</span>
<span class="lineNum">    2341 </span><span class="lineNoCov">          0 :         clb = 0;</span>
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :         cub = 0x10FFFF;</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2344 </span>            :     }
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span><span class="lineNoCov">          0 :     if(!constraints || !constraints-&gt;per_constraints)</span>
<span class="lineNum">    2347 </span><span class="lineNoCov">          0 :         constraints = &amp;td-&gt;encoding_constraints;</span>
<span class="lineNum">    2348 </span><span class="lineNoCov">          0 :     if(constraints-&gt;per_constraints) {</span>
<span class="lineNum">    2349 </span><span class="lineNoCov">          0 :         const asn_per_constraint_t *pc = &amp;constraints-&gt;per_constraints-&gt;value;</span>
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 :         if(pc-&gt;flags &amp; APC_SEMI_CONSTRAINED) {</span>
<span class="lineNum">    2351 </span><span class="lineNoCov">          0 :             clb = pc-&gt;lower_bound;</span>
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :         } else if(pc-&gt;flags &amp; APC_CONSTRAINED) {</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :             clb = pc-&gt;lower_bound;</span>
<span class="lineNum">    2354 </span><span class="lineNoCov">          0 :             cub = pc-&gt;upper_bound;</span>
<span class="lineNum">    2355 </span>            :         }
<span class="lineNum">    2356 </span>            :     }
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :     rnd_len =</span>
<span class="lineNum">    2359 </span>            :         OCTET_STRING_random_length_constrained(td, constraints, max_length);
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :     buf = CALLOC(unit_bytes, rnd_len + 1);</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :     if(!buf) return result_failed;</span>
<span class="lineNum">    2363 </span>            : 
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :     bend = &amp;buf[unit_bytes * rnd_len];</span>
<span class="lineNum">    2365 </span>            : 
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :     switch(unit_bytes) {</span>
<span class="lineNum">    2367 </span>            :     case 1:
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :         for(b = buf; b &lt; bend; b += unit_bytes) {</span>
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :             *(uint8_t *)b = OCTET_STRING__random_char(clb, cub);</span>
<span class="lineNum">    2370 </span>            :         }
<span class="lineNum">    2371 </span><span class="lineNoCov">          0 :         *(uint8_t *)b = 0;</span>
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2373 </span>            :     case 2:
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :         for(b = buf; b &lt; bend; b += unit_bytes) {</span>
<span class="lineNum">    2375 </span><span class="lineNoCov">          0 :             uint32_t code = OCTET_STRING__random_char(clb, cub);</span>
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :             b[0] = code &gt;&gt; 8;</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :             b[1] = code;</span>
<span class="lineNum">    2378 </span>            :         }
<span class="lineNum">    2379 </span><span class="lineNoCov">          0 :         *(uint16_t *)b = 0;</span>
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2381 </span>            :     case 4:
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :         for(b = buf; b &lt; bend; b += unit_bytes) {</span>
<span class="lineNum">    2383 </span><span class="lineNoCov">          0 :             uint32_t code = OCTET_STRING__random_char(clb, cub);</span>
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :             b[0] = code &gt;&gt; 24;</span>
<span class="lineNum">    2385 </span><span class="lineNoCov">          0 :             b[1] = code &gt;&gt; 16;</span>
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :             b[2] = code &gt;&gt; 8;</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :             b[3] = code;</span>
<span class="lineNum">    2388 </span>            :         }
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :         *(uint32_t *)b = 0;</span>
<span class="lineNum">    2390 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    2391 </span>            :     }
<span class="lineNum">    2392 </span>            : 
<span class="lineNum">    2393 </span><span class="lineNoCov">          0 :     if(*sptr) {</span>
<span class="lineNum">    2394 </span><span class="lineNoCov">          0 :         st = *sptr;</span>
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :         FREEMEM(st-&gt;buf);</span>
<span class="lineNum">    2396 </span>            :     } else {
<span class="lineNum">    2397 </span><span class="lineNoCov">          0 :         st = (OCTET_STRING_t *)(*sptr = CALLOC(1, specs-&gt;struct_size));</span>
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :         if(!st) {</span>
<span class="lineNum">    2399 </span><span class="lineNoCov">          0 :             FREEMEM(buf);</span>
<span class="lineNum">    2400 </span><span class="lineNoCov">          0 :             return result_failed;</span>
<span class="lineNum">    2401 </span>            :         }
<span class="lineNum">    2402 </span>            :     }
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span><span class="lineNoCov">          0 :     st-&gt;buf = buf;</span>
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :     st-&gt;size = unit_bytes * rnd_len;</span>
<span class="lineNum">    2406 </span>            : 
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :     result_ok.length = st-&gt;size;</span>
<span class="lineNum">    2408 </span><span class="lineNoCov">          0 :     return result_ok;</span>
<span class="lineNum">    2409 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
