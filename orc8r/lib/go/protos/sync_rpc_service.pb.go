// Code generated by protoc-gen-go. DO NOT EDIT.
// source: orc8r/protos/sync_rpc_service.proto

package protos

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type GatewayRequest struct {
	GwId string `protobuf:"bytes,1,opt,name=gwId,proto3" json:"gwId,omitempty"`
	// sync_rpc_service leverages the fact that grpc is built on top of http/2.
	// As pseudo header :method will always be POST, and :scheme will always be http,
	// they are excluded from the message definition. grpc uses pseudo header :authority
	// and :path to route the rpc calls to the corresponding services
	Authority string `protobuf:"bytes,2,opt,name=authority,proto3" json:"authority,omitempty"`
	Path      string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	// non-pseudo headers
	Headers              map[string]string `protobuf:"bytes,5,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Payload              []byte            `protobuf:"bytes,6,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GatewayRequest) Reset()         { *m = GatewayRequest{} }
func (m *GatewayRequest) String() string { return proto.CompactTextString(m) }
func (*GatewayRequest) ProtoMessage()    {}
func (*GatewayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{0}
}

func (m *GatewayRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GatewayRequest.Unmarshal(m, b)
}
func (m *GatewayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GatewayRequest.Marshal(b, m, deterministic)
}
func (m *GatewayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayRequest.Merge(m, src)
}
func (m *GatewayRequest) XXX_Size() int {
	return xxx_messageInfo_GatewayRequest.Size(m)
}
func (m *GatewayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayRequest proto.InternalMessageInfo

func (m *GatewayRequest) GetGwId() string {
	if m != nil {
		return m.GwId
	}
	return ""
}

func (m *GatewayRequest) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *GatewayRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GatewayRequest) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GatewayRequest) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type GatewayResponse struct {
	// pseudo header :status
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// non-pseudo headers
	Headers map[string]string `protobuf:"bytes,2,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// response body
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	// err message to return to the caller, if any
	Err string `protobuf:"bytes,4,opt,name=err,proto3" json:"err,omitempty"`
	// keepConnActive is used to tell the client that the connection is still active, even if no response has
	// been received for a while
	KeepConnActive       bool     `protobuf:"varint,5,opt,name=keepConnActive,proto3" json:"keepConnActive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GatewayResponse) Reset()         { *m = GatewayResponse{} }
func (m *GatewayResponse) String() string { return proto.CompactTextString(m) }
func (*GatewayResponse) ProtoMessage()    {}
func (*GatewayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{1}
}

func (m *GatewayResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GatewayResponse.Unmarshal(m, b)
}
func (m *GatewayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GatewayResponse.Marshal(b, m, deterministic)
}
func (m *GatewayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GatewayResponse.Merge(m, src)
}
func (m *GatewayResponse) XXX_Size() int {
	return xxx_messageInfo_GatewayResponse.Size(m)
}
func (m *GatewayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GatewayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GatewayResponse proto.InternalMessageInfo

func (m *GatewayResponse) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *GatewayResponse) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *GatewayResponse) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *GatewayResponse) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

func (m *GatewayResponse) GetKeepConnActive() bool {
	if m != nil {
		return m.KeepConnActive
	}
	return false
}

// SyncRPCRequest is sent down to gateway from cloud
type SyncRPCRequest struct {
	// unique request Id passed in from cloud
	ReqId   uint32          `protobuf:"varint,1,opt,name=reqId,proto3" json:"reqId,omitempty"`
	ReqBody *GatewayRequest `protobuf:"bytes,2,opt,name=reqBody,proto3" json:"reqBody,omitempty"`
	// cloud will send a heartBeat every minute, if no other requests are sent
	// down to the gateway
	HeartBeat bool `protobuf:"varint,3,opt,name=heartBeat,proto3" json:"heartBeat,omitempty"`
	// connClosed is set to true when the client closes the connection
	ConnClosed           bool     `protobuf:"varint,4,opt,name=connClosed,proto3" json:"connClosed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRPCRequest) Reset()         { *m = SyncRPCRequest{} }
func (m *SyncRPCRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRPCRequest) ProtoMessage()    {}
func (*SyncRPCRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{2}
}

func (m *SyncRPCRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncRPCRequest.Unmarshal(m, b)
}
func (m *SyncRPCRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncRPCRequest.Marshal(b, m, deterministic)
}
func (m *SyncRPCRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRPCRequest.Merge(m, src)
}
func (m *SyncRPCRequest) XXX_Size() int {
	return xxx_messageInfo_SyncRPCRequest.Size(m)
}
func (m *SyncRPCRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRPCRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRPCRequest proto.InternalMessageInfo

func (m *SyncRPCRequest) GetReqId() uint32 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

func (m *SyncRPCRequest) GetReqBody() *GatewayRequest {
	if m != nil {
		return m.ReqBody
	}
	return nil
}

func (m *SyncRPCRequest) GetHeartBeat() bool {
	if m != nil {
		return m.HeartBeat
	}
	return false
}

func (m *SyncRPCRequest) GetConnClosed() bool {
	if m != nil {
		return m.ConnClosed
	}
	return false
}

// SyncRPCResponse is sent from gateway to cloud
type SyncRPCResponse struct {
	ReqId    uint32           `protobuf:"varint,1,opt,name=reqId,proto3" json:"reqId,omitempty"`
	RespBody *GatewayResponse `protobuf:"bytes,2,opt,name=respBody,proto3" json:"respBody,omitempty"`
	// gateway will send a heartBeat if it hasn't received SyncRPCRequests from cloud for a while.
	// If it's a heartbeat, reqId and respBody will be ignored.
	HeartBeat            bool     `protobuf:"varint,3,opt,name=heartBeat,proto3" json:"heartBeat,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SyncRPCResponse) Reset()         { *m = SyncRPCResponse{} }
func (m *SyncRPCResponse) String() string { return proto.CompactTextString(m) }
func (*SyncRPCResponse) ProtoMessage()    {}
func (*SyncRPCResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{3}
}

func (m *SyncRPCResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SyncRPCResponse.Unmarshal(m, b)
}
func (m *SyncRPCResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SyncRPCResponse.Marshal(b, m, deterministic)
}
func (m *SyncRPCResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRPCResponse.Merge(m, src)
}
func (m *SyncRPCResponse) XXX_Size() int {
	return xxx_messageInfo_SyncRPCResponse.Size(m)
}
func (m *SyncRPCResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRPCResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRPCResponse proto.InternalMessageInfo

func (m *SyncRPCResponse) GetReqId() uint32 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

func (m *SyncRPCResponse) GetRespBody() *GatewayResponse {
	if m != nil {
		return m.RespBody
	}
	return nil
}

func (m *SyncRPCResponse) GetHeartBeat() bool {
	if m != nil {
		return m.HeartBeat
	}
	return false
}

type HardwareID struct {
	Hwid                 string   `protobuf:"bytes,1,opt,name=hwid,proto3" json:"hwid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HardwareID) Reset()         { *m = HardwareID{} }
func (m *HardwareID) String() string { return proto.CompactTextString(m) }
func (*HardwareID) ProtoMessage()    {}
func (*HardwareID) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{4}
}

func (m *HardwareID) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HardwareID.Unmarshal(m, b)
}
func (m *HardwareID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HardwareID.Marshal(b, m, deterministic)
}
func (m *HardwareID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareID.Merge(m, src)
}
func (m *HardwareID) XXX_Size() int {
	return xxx_messageInfo_HardwareID.Size(m)
}
func (m *HardwareID) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareID.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareID proto.InternalMessageInfo

func (m *HardwareID) GetHwid() string {
	if m != nil {
		return m.Hwid
	}
	return ""
}

type Hostname struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Hostname) Reset()         { *m = Hostname{} }
func (m *Hostname) String() string { return proto.CompactTextString(m) }
func (*Hostname) ProtoMessage()    {}
func (*Hostname) Descriptor() ([]byte, []int) {
	return fileDescriptor_22887391e8a5ac6c, []int{5}
}

func (m *Hostname) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Hostname.Unmarshal(m, b)
}
func (m *Hostname) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Hostname.Marshal(b, m, deterministic)
}
func (m *Hostname) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hostname.Merge(m, src)
}
func (m *Hostname) XXX_Size() int {
	return xxx_messageInfo_Hostname.Size(m)
}
func (m *Hostname) XXX_DiscardUnknown() {
	xxx_messageInfo_Hostname.DiscardUnknown(m)
}

var xxx_messageInfo_Hostname proto.InternalMessageInfo

func (m *Hostname) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func init() {
	proto.RegisterType((*GatewayRequest)(nil), "magma.orc8r.GatewayRequest")
	proto.RegisterMapType((map[string]string)(nil), "magma.orc8r.GatewayRequest.HeadersEntry")
	proto.RegisterType((*GatewayResponse)(nil), "magma.orc8r.GatewayResponse")
	proto.RegisterMapType((map[string]string)(nil), "magma.orc8r.GatewayResponse.HeadersEntry")
	proto.RegisterType((*SyncRPCRequest)(nil), "magma.orc8r.SyncRPCRequest")
	proto.RegisterType((*SyncRPCResponse)(nil), "magma.orc8r.SyncRPCResponse")
	proto.RegisterType((*HardwareID)(nil), "magma.orc8r.HardwareID")
	proto.RegisterType((*Hostname)(nil), "magma.orc8r.Hostname")
}

func init() {
	proto.RegisterFile("orc8r/protos/sync_rpc_service.proto", fileDescriptor_22887391e8a5ac6c)
}

var fileDescriptor_22887391e8a5ac6c = []byte{
	// 533 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xcd, 0x6e, 0xda, 0x40,
	0x10, 0x8e, 0x43, 0xf8, 0xc9, 0x90, 0x92, 0x6a, 0x95, 0xa6, 0x2e, 0x44, 0x11, 0x72, 0xa5, 0xca,
	0xbd, 0x40, 0x45, 0x55, 0x09, 0xe5, 0x56, 0x68, 0x12, 0xd2, 0x53, 0xb5, 0x39, 0xb5, 0x97, 0x68,
	0xb1, 0x47, 0xd8, 0x0a, 0x78, 0xcd, 0xec, 0x02, 0xf2, 0xa9, 0x0f, 0xd2, 0x97, 0xec, 0x13, 0xb4,
	0x95, 0xff, 0x00, 0x47, 0x88, 0x1e, 0x72, 0xda, 0x99, 0xf9, 0x66, 0x76, 0xbf, 0x6f, 0x66, 0x77,
	0xe1, 0xad, 0x24, 0xa7, 0x4f, 0xdd, 0x90, 0xa4, 0x96, 0xaa, 0xab, 0xa2, 0xc0, 0x79, 0xa0, 0xd0,
	0x79, 0x50, 0x48, 0x4b, 0xdf, 0xc1, 0x4e, 0x12, 0x67, 0xf5, 0x99, 0x98, 0xcc, 0x44, 0x27, 0x49,
	0xb5, 0x7e, 0x1b, 0xd0, 0xb8, 0x15, 0x1a, 0x57, 0x22, 0xe2, 0x38, 0x5f, 0xa0, 0xd2, 0x8c, 0xc1,
	0xd1, 0x64, 0x75, 0xe7, 0x9a, 0x46, 0xdb, 0xb0, 0x8f, 0x79, 0x62, 0xb3, 0x0b, 0x38, 0x16, 0x0b,
	0xed, 0x49, 0xf2, 0x75, 0x64, 0x1e, 0x26, 0xc0, 0x26, 0x10, 0x57, 0x84, 0x42, 0x7b, 0x66, 0x29,
	0xad, 0x88, 0x6d, 0x36, 0x80, 0xaa, 0x87, 0xc2, 0x45, 0x52, 0x66, 0xb9, 0x5d, 0xb2, 0xeb, 0x3d,
	0xbb, 0xb3, 0x75, 0x6e, 0xa7, 0x78, 0x66, 0x67, 0x94, 0xa6, 0x5e, 0x07, 0x9a, 0x22, 0x9e, 0x17,
	0x32, 0x13, 0xaa, 0xa1, 0x88, 0xa6, 0x52, 0xb8, 0x66, 0xa5, 0x6d, 0xd8, 0x27, 0x3c, 0x77, 0x9b,
	0x57, 0x70, 0xb2, 0x5d, 0xc2, 0x5e, 0x42, 0xe9, 0x11, 0xa3, 0x8c, 0x72, 0x6c, 0xb2, 0x33, 0x28,
	0x2f, 0xc5, 0x74, 0x81, 0x19, 0xdb, 0xd4, 0xb9, 0x3a, 0xec, 0x1b, 0xd6, 0x1f, 0x03, 0x4e, 0xd7,
	0xc7, 0xab, 0x50, 0x06, 0x0a, 0xd9, 0x39, 0x54, 0x94, 0x16, 0x7a, 0xa1, 0xb2, 0x2d, 0x32, 0x8f,
	0x0d, 0x37, 0x2a, 0x0e, 0x13, 0x15, 0xef, 0x77, 0xab, 0x48, 0xb7, 0xf9, 0xbf, 0x8c, 0x52, 0x41,
	0x46, 0x4c, 0x1b, 0x89, 0xcc, 0xa3, 0x94, 0x36, 0x12, 0xb1, 0x77, 0xd0, 0x78, 0x44, 0x0c, 0x87,
	0x32, 0x08, 0x3e, 0x3b, 0xda, 0x5f, 0xa2, 0x59, 0x6e, 0x1b, 0x76, 0x8d, 0x3f, 0x89, 0x3e, 0xab,
	0x01, 0xbf, 0x0c, 0x68, 0xdc, 0x47, 0x81, 0xc3, 0xbf, 0x0d, 0xf3, 0x99, 0x9f, 0x41, 0x99, 0x70,
	0x9e, 0x0d, 0xfd, 0x05, 0x4f, 0x1d, 0xf6, 0x09, 0xaa, 0x84, 0xf3, 0x81, 0x74, 0xd3, 0x99, 0xd7,
	0x7b, 0xad, 0x3d, 0x33, 0xe4, 0x79, 0x6e, 0x7c, 0x59, 0x3c, 0x14, 0xa4, 0x07, 0x28, 0x74, 0xa2,
	0xb8, 0xc6, 0x37, 0x01, 0x76, 0x09, 0xe0, 0xc8, 0x20, 0x18, 0x4e, 0xa5, 0x42, 0x37, 0x91, 0x5e,
	0xe3, 0x5b, 0x11, 0xeb, 0x27, 0x9c, 0xae, 0xc9, 0x65, 0xd3, 0xd9, 0xcd, 0xae, 0x0f, 0x35, 0x42,
	0x15, 0x6e, 0xd1, 0xbb, 0xd8, 0x37, 0x1c, 0xbe, 0xce, 0xde, 0x4f, 0xd0, 0x6a, 0x03, 0x8c, 0x04,
	0xb9, 0x2b, 0x41, 0x78, 0xf7, 0x25, 0xbe, 0xdb, 0xde, 0xca, 0x5f, 0xbf, 0x86, 0xd8, 0xb6, 0x2e,
	0xa1, 0x36, 0x92, 0x4a, 0x07, 0x62, 0x86, 0x31, 0x1e, 0xaf, 0x39, 0x1e, 0xdb, 0xbd, 0xbf, 0x9b,
	0x06, 0xdf, 0xa7, 0x4f, 0x8f, 0x7d, 0x87, 0xf3, 0x6b, 0xa5, 0xc5, 0x78, 0xea, 0x2b, 0x2f, 0x87,
	0x34, 0xa1, 0x98, 0xb1, 0x22, 0xe9, 0x27, 0xd2, 0x9b, 0xad, 0xdd, 0x68, 0xd2, 0x71, 0xeb, 0xc0,
	0x36, 0x3e, 0x18, 0xec, 0x2b, 0x54, 0xb3, 0xf8, 0xf3, 0xf7, 0xba, 0x01, 0x76, 0x8b, 0x3a, 0x17,
	0x77, 0x23, 0x69, 0xb4, 0xf2, 0x5d, 0xf6, 0xba, 0x50, 0xb8, 0x69, 0x4e, 0xf3, 0x55, 0x11, 0xc8,
	0xca, 0xac, 0x83, 0x41, 0xeb, 0xc7, 0x9b, 0x04, 0xe9, 0xa6, 0x1f, 0xd2, 0xd4, 0x1f, 0x77, 0x27,
	0x32, 0xfb, 0x97, 0xc6, 0x95, 0x64, 0xfd, 0xf8, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x10, 0xa2,
	0x87, 0xae, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// SyncRPCServiceClient is the client API for SyncRPCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SyncRPCServiceClient interface {
	// creates a bidirectional stream from gateway to cloud
	// so cloud can send in SyncRPCRequest, and wait for SyncRPCResponse.
	// This will be the underlying service for Synchronous RPC from the cloud.
	EstablishSyncRPCStream(ctx context.Context, opts ...grpc.CallOption) (SyncRPCService_EstablishSyncRPCStreamClient, error)
	// same method as EstablishSyncRPCStream, but named differently for backward compatibility
	SyncRPC(ctx context.Context, opts ...grpc.CallOption) (SyncRPCService_SyncRPCClient, error)
	// returns the hostname mapped to the current hwid
	GetHostnameForHwid(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (*Hostname, error)
}

type syncRPCServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncRPCServiceClient(cc grpc.ClientConnInterface) SyncRPCServiceClient {
	return &syncRPCServiceClient{cc}
}

func (c *syncRPCServiceClient) EstablishSyncRPCStream(ctx context.Context, opts ...grpc.CallOption) (SyncRPCService_EstablishSyncRPCStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SyncRPCService_serviceDesc.Streams[0], "/magma.orc8r.SyncRPCService/EstablishSyncRPCStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &syncRPCServiceEstablishSyncRPCStreamClient{stream}
	return x, nil
}

type SyncRPCService_EstablishSyncRPCStreamClient interface {
	Send(*SyncRPCResponse) error
	Recv() (*SyncRPCRequest, error)
	grpc.ClientStream
}

type syncRPCServiceEstablishSyncRPCStreamClient struct {
	grpc.ClientStream
}

func (x *syncRPCServiceEstablishSyncRPCStreamClient) Send(m *SyncRPCResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *syncRPCServiceEstablishSyncRPCStreamClient) Recv() (*SyncRPCRequest, error) {
	m := new(SyncRPCRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *syncRPCServiceClient) SyncRPC(ctx context.Context, opts ...grpc.CallOption) (SyncRPCService_SyncRPCClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SyncRPCService_serviceDesc.Streams[1], "/magma.orc8r.SyncRPCService/SyncRPC", opts...)
	if err != nil {
		return nil, err
	}
	x := &syncRPCServiceSyncRPCClient{stream}
	return x, nil
}

type SyncRPCService_SyncRPCClient interface {
	Send(*SyncRPCResponse) error
	Recv() (*SyncRPCRequest, error)
	grpc.ClientStream
}

type syncRPCServiceSyncRPCClient struct {
	grpc.ClientStream
}

func (x *syncRPCServiceSyncRPCClient) Send(m *SyncRPCResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *syncRPCServiceSyncRPCClient) Recv() (*SyncRPCRequest, error) {
	m := new(SyncRPCRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *syncRPCServiceClient) GetHostnameForHwid(ctx context.Context, in *HardwareID, opts ...grpc.CallOption) (*Hostname, error) {
	out := new(Hostname)
	err := c.cc.Invoke(ctx, "/magma.orc8r.SyncRPCService/GetHostnameForHwid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncRPCServiceServer is the server API for SyncRPCService service.
type SyncRPCServiceServer interface {
	// creates a bidirectional stream from gateway to cloud
	// so cloud can send in SyncRPCRequest, and wait for SyncRPCResponse.
	// This will be the underlying service for Synchronous RPC from the cloud.
	EstablishSyncRPCStream(SyncRPCService_EstablishSyncRPCStreamServer) error
	// same method as EstablishSyncRPCStream, but named differently for backward compatibility
	SyncRPC(SyncRPCService_SyncRPCServer) error
	// returns the hostname mapped to the current hwid
	GetHostnameForHwid(context.Context, *HardwareID) (*Hostname, error)
}

// UnimplementedSyncRPCServiceServer can be embedded to have forward compatible implementations.
type UnimplementedSyncRPCServiceServer struct {
}

func (*UnimplementedSyncRPCServiceServer) EstablishSyncRPCStream(srv SyncRPCService_EstablishSyncRPCStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EstablishSyncRPCStream not implemented")
}
func (*UnimplementedSyncRPCServiceServer) SyncRPC(srv SyncRPCService_SyncRPCServer) error {
	return status.Errorf(codes.Unimplemented, "method SyncRPC not implemented")
}
func (*UnimplementedSyncRPCServiceServer) GetHostnameForHwid(ctx context.Context, req *HardwareID) (*Hostname, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHostnameForHwid not implemented")
}

func RegisterSyncRPCServiceServer(s *grpc.Server, srv SyncRPCServiceServer) {
	s.RegisterService(&_SyncRPCService_serviceDesc, srv)
}

func _SyncRPCService_EstablishSyncRPCStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SyncRPCServiceServer).EstablishSyncRPCStream(&syncRPCServiceEstablishSyncRPCStreamServer{stream})
}

type SyncRPCService_EstablishSyncRPCStreamServer interface {
	Send(*SyncRPCRequest) error
	Recv() (*SyncRPCResponse, error)
	grpc.ServerStream
}

type syncRPCServiceEstablishSyncRPCStreamServer struct {
	grpc.ServerStream
}

func (x *syncRPCServiceEstablishSyncRPCStreamServer) Send(m *SyncRPCRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *syncRPCServiceEstablishSyncRPCStreamServer) Recv() (*SyncRPCResponse, error) {
	m := new(SyncRPCResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SyncRPCService_SyncRPC_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SyncRPCServiceServer).SyncRPC(&syncRPCServiceSyncRPCServer{stream})
}

type SyncRPCService_SyncRPCServer interface {
	Send(*SyncRPCRequest) error
	Recv() (*SyncRPCResponse, error)
	grpc.ServerStream
}

type syncRPCServiceSyncRPCServer struct {
	grpc.ServerStream
}

func (x *syncRPCServiceSyncRPCServer) Send(m *SyncRPCRequest) error {
	return x.ServerStream.SendMsg(m)
}

func (x *syncRPCServiceSyncRPCServer) Recv() (*SyncRPCResponse, error) {
	m := new(SyncRPCResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SyncRPCService_GetHostnameForHwid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HardwareID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncRPCServiceServer).GetHostnameForHwid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/magma.orc8r.SyncRPCService/GetHostnameForHwid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncRPCServiceServer).GetHostnameForHwid(ctx, req.(*HardwareID))
	}
	return interceptor(ctx, in, info, handler)
}

var _SyncRPCService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "magma.orc8r.SyncRPCService",
	HandlerType: (*SyncRPCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetHostnameForHwid",
			Handler:    _SyncRPCService_GetHostnameForHwid_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EstablishSyncRPCStream",
			Handler:       _SyncRPCService_EstablishSyncRPCStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SyncRPC",
			Handler:       _SyncRPCService_SyncRPC_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "orc8r/protos/sync_rpc_service.proto",
}
